‚úÖ Excellent ‚Äî that error message tells us Entity Framework Core is trying to compose (e.g., filter, sort, or track) over a stored procedure call that returns a full result set (non-composable SQL).

Let‚Äôs fix this properly and safely.


---

‚ö†Ô∏è Error explanation

> System.InvalidOperationException: 'FromSql' or 'SqlQuery' was called with non-composable SQL ...'



This happens when you use:

_context.Categories.FromSqlRaw("EXEC sp_GetCategories").ToList();

and EF tries to build an extra query on top (like adding .OrderBy, .Where, or tracking changes).

Since EXEC sp_* is non-composable SQL, EF can‚Äôt mix its own SQL syntax with that stored procedure.


---

‚úÖ Correct Fix Options

Option 1: Use AsNoTracking()

This is the simplest and safest way.

In your controller actions where you use FromSqlRaw, add .AsNoTracking() before .ToListAsync() or .FirstOrDefaultAsync():

Example ‚Äì Fixed Index and Edit:

// List
var categories = await _context.Categories
    .FromSqlRaw("EXEC sp_GetCategories")
    .AsNoTracking()
    .ToListAsync();

Example ‚Äì Fixed Edit

var category = await _context.Categories
    .FromSqlRaw("EXEC sp_GetCategoryById @CategoryID", 
        new SqlParameter("@CategoryID", id))
    .AsNoTracking()
    .FirstOrDefaultAsync();

‚úÖ AsNoTracking() tells EF not to compose or track entities ‚Äî perfect for stored procs returning read-only results.


---

Option 2: Call .AsEnumerable() (Alternative)

If you really need to perform client-side filtering, call .AsEnumerable() after the stored procedure, so EF won‚Äôt try to push it to SQL Server.

Example:

var categories = _context.Categories
    .FromSqlRaw("EXEC sp_GetCategories")
    .AsEnumerable()
    .Where(c => c.CategoryName.StartsWith("A"))
    .ToList();

But usually, you won‚Äôt need this for simple CRUD.


---

Option 3: Use Database.ExecuteSqlRawAsync for Non-Query SPs

You already did this correctly for INSERT, UPDATE, and DELETE.
Keep using:

await _context.Database.ExecuteSqlRawAsync("EXEC sp_UpdateCategory ...");

That part is perfect.


---

‚úÖ Final Working Example (Safe Version)

Here‚Äôs your corrected Index and Edit action snippets:

// INDEX
public async Task<IActionResult> Index()
{
    var categories = await _context.Categories
        .FromSqlRaw("EXEC sp_GetCategories")
        .AsNoTracking()
        .ToListAsync();
    return View(categories);
}

// EDIT (GET)
public async Task<IActionResult> Edit(int id)
{
    var category = await _context.Categories
        .FromSqlRaw("EXEC sp_GetCategoryById @CategoryID", new SqlParameter("@CategoryID", id))
        .AsNoTracking()
        .FirstOrDefaultAsync();

    if (category == null)
        return NotFound();

    return View(category);
}


---

Would you like me to show a fully updated working version of the entire controller (CategoryController) with all the .AsNoTracking() fixes applied?

**

System.InvalidOperationException: ''FromSql' or 'SqlQuery' was called with non-composable SQL and with a query composing over it. Consider calling 'AsEnumerable' after the method to perform the composition on the client side.'


**

Sure üëç Let‚Äôs build a complete CRUD sample for tbl_category using ASP.NET Core MVC + SQL Server Stored Procedures ‚Äî clean and ready to run.

We‚Äôll go step by step:


---

üß© 1. SQL Server Setup

First, create your database table and stored procedures.

üóÑÔ∏è Table

CREATE TABLE tbl_category (
    CategoryID INT IDENTITY(1,1) PRIMARY KEY,
    CategoryName NVARCHAR(100) NOT NULL,
    Description NVARCHAR(255)
);

‚öôÔ∏è Stored Procedures

-- 1. Get all categories
CREATE PROCEDURE sp_GetCategories
AS
BEGIN
    SELECT CategoryID, CategoryName, Description
    FROM tbl_category
    ORDER BY CategoryID DESC;
END
GO

-- 2. Get category by ID
CREATE PROCEDURE sp_GetCategoryById
    @CategoryID INT
AS
BEGIN
    SELECT CategoryID, CategoryName, Description
    FROM tbl_category
    WHERE CategoryID = @CategoryID;
END
GO

-- 3. Insert new category
CREATE PROCEDURE sp_InsertCategory
    @CategoryName NVARCHAR(100),
    @Description NVARCHAR(255)
AS
BEGIN
    INSERT INTO tbl_category (CategoryName, Description)
    VALUES (@CategoryName, @Description);
END
GO

-- 4. Update category
CREATE PROCEDURE sp_UpdateCategory
    @CategoryID INT,
    @CategoryName NVARCHAR(100),
    @Description NVARCHAR(255)
AS
BEGIN
    UPDATE tbl_category
    SET CategoryName = @CategoryName,
        Description = @Description
    WHERE CategoryID = @CategoryID;
END
GO

-- 5. Delete category
CREATE PROCEDURE sp_DeleteCategory
    @CategoryID INT
AS
BEGIN
    DELETE FROM tbl_category WHERE CategoryID = @CategoryID;
END
GO


---

üß† 2. Model (Models/Category.cs)

using System.ComponentModel.DataAnnotations;

namespace YourAppName.Models
{
    public class Category
    {
        [Key]
        public int CategoryID { get; set; }

        [Required(ErrorMessage = "Category name is required")]
        public string CategoryName { get; set; }

        public string Description { get; set; }
    }
}


---

‚öôÔ∏è 3. Database Context (Data/ApplicationDbContext.cs)

using Microsoft.EntityFrameworkCore;
using YourAppName.Models;

namespace YourAppName.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<Category> Categories { get; set; }
    }
}

In appsettings.json:

"ConnectionStrings": {
  "DefaultConnection": "Server=YOUR_SERVER_NAME;Database=YourDB;Trusted_Connection=True;TrustServerCertificate=True;"
}

In Program.cs:

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));


---

üß© 4. Controller (Controllers/CategoryController.cs)

using Microsoft.AspNetCore.Mvc;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;
using YourAppName.Data;
using YourAppName.Models;

namespace YourAppName.Controllers
{
    public class CategoryController : Controller
    {
        private readonly ApplicationDbContext _context;

        public CategoryController(ApplicationDbContext context)
        {
            _context = context;
        }

        // READ: List all
        public async Task<IActionResult> Index()
        {
            var categories = await _context.Categories
                .FromSqlRaw("EXEC sp_GetCategories")
                .ToListAsync();
            return View(categories);
        }

        // CREATE: View
        public IActionResult Create()
        {
            return View();
        }

        // CREATE: POST
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Category category)
        {
            if (ModelState.IsValid)
            {
                await _context.Database.ExecuteSqlRawAsync(
                    "EXEC sp_InsertCategory @CategoryName, @Description",
                    new SqlParameter("@CategoryName", category.CategoryName),
                    new SqlParameter("@Description", category.Description ?? (object)DBNull.Value)
                );
                return RedirectToAction(nameof(Index));
            }
            return View(category);
        }

        // EDIT: View
        public async Task<IActionResult> Edit(int id)
        {
            var category = await _context.Categories
                .FromSqlRaw("EXEC sp_GetCategoryById @CategoryID", new SqlParameter("@CategoryID", id))
                .AsNoTracking()
                .FirstOrDefaultAsync();

            if (category == null)
                return NotFound();

            return View(category);
        }

        // EDIT: POST
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, Category category)
        {
            if (id != category.CategoryID) return NotFound();

            if (ModelState.IsValid)
            {
                await _context.Database.ExecuteSqlRawAsync(
                    "EXEC sp_UpdateCategory @CategoryID, @CategoryName, @Description",
                    new SqlParameter("@CategoryID", category.CategoryID),
                    new SqlParameter("@CategoryName", category.CategoryName),
                    new SqlParameter("@Description", category.Description ?? (object)DBNull.Value)
                );
                return RedirectToAction(nameof(Index));
            }

            return View(category);
        }

        // DELETE: View
        public async Task<IActionResult> Delete(int id)
        {
            var category = await _context.Categories
                .FromSqlRaw("EXEC sp_GetCategoryById @CategoryID", new SqlParameter("@CategoryID", id))
                .AsNoTracking()
                .FirstOrDefaultAsync();

            if (category == null)
                return NotFound();

            return View(category);
        }

        // DELETE: POST
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            await _context.Database.ExecuteSqlRawAsync(
                "EXEC sp_DeleteCategory @CategoryID",
                new SqlParameter("@CategoryID", id)
            );

            return RedirectToAction(nameof(Index));
        }

        // DETAILS
        public async Task<IActionResult> Details(int id)
        {
            var category = await _context.Categories
                .FromSqlRaw("EXEC sp_GetCategoryById @CategoryID", new SqlParameter("@CategoryID", id))
                .AsNoTracking()
                .FirstOrDefaultAsync();

            if (category == null)
                return NotFound();

            return View(category);
        }
    }
}


---

üñ•Ô∏è 5. Views

Generate these Razor views under:

Views/Category/
    Index.cshtml
    Create.cshtml
    Edit.cshtml
    Delete.cshtml
    Details.cshtml

Example: Index.cshtml

@model IEnumerable<YourAppName.Models.Category>

<h2>Category List</h2>
<a asp-action="Create" class="btn btn-primary">Add New</a>
<table class="table table-striped mt-3">
    <thead>
        <tr>
            <th>ID</th>
            <th>Category Name</th>
            <th>Description</th>
            <th></th>
        </tr>
    </thead>
    <tbody>
        @foreach (var item in Model)
        {
            <tr>
                <td>@item.CategoryID</td>
                <td>@item.CategoryName</td>
                <td>@item.Description</td>
                <td>
                    <a asp-action="Edit" asp-route-id="@item.CategoryID" class="btn btn-sm btn-warning">Edit</a>
                    <a asp-action="Details" asp-route-id="@item.CategoryID" class="btn btn-sm btn-info">Details</a>
                    <a asp-action="Delete" asp-route-id="@item.CategoryID" class="btn btn-sm btn-danger">Delete</a>
                </td>
            </tr>
        }
    </tbody>
</table>

The Create, Edit, Delete, and Details pages can be generated easily using Visual Studio scaffolding.


---

‚úÖ Summary

Operation	Stored Procedure Used	MVC Action	SQL Execution

List	sp_GetCategories	Index	FromSqlRaw
Create	sp_InsertCategory	Create	ExecuteSqlRawAsync
Edit	sp_UpdateCategory	Edit	ExecuteSqlRawAsync
Delete	sp_DeleteCategory	DeleteConfirmed	ExecuteSqlRawAsync
Details	sp_GetCategoryById	Details	FromSqlRaw



---

Would you like me to include Bootstrap + DataTables design for the Index.cshtml (for search, sort, and pagination)? It makes the CRUD look more professional.
