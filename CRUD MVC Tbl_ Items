

**

var items = await _context.Items
in ItemController.cs
Error: InvalidOperationException: The required column 'ControlNo' was not present in the results of a 'FromSql' operation.

**

Got it ‚Äî these 2 errors are expected because:
1Ô∏è‚É£ Your Category model does not yet contain CategoryCode
2Ô∏è‚É£ EF Core 8 does NOT have SqlQuery<T> anymore ‚Äî it was replaced with Database.SqlQueryRaw<T>.

Let‚Äôs fix both cleanly and correctly.


---

‚úÖ FIX 1 ‚Äî Add CategoryCode Property in Category Model

In Models/Category.cs, add:

public string CategoryCode { get; set; } = string.Empty;

Full model should look like:

public class Category
{
    public int CategoryID { get; set; }
    public string CategoryName { get; set; } = string.Empty;
    public string Uom { get; set; } = string.Empty;
    public int Quantity { get; set; }
    public string CategoryCode { get; set; } = string.Empty;
}

üëâ After adding this, rebuild the project.


---

‚úÖ FIX 2 ‚Äî Replace SqlQuery With SqlQueryRaw (EF Core 8)

You used this:

_context.Database.SqlQuery<int>("EXEC sp_GetMaxControlNoSeq @CategoryCode, @MMYY",
    sqlCategoryCode, sqlMMYY)
    .FirstOrDefault();

But EF Core 8 uses:

Database.SqlQueryRaw<T>

‚úîÔ∏è Here is the corrected version:

int maxSeq = _context.Database
    .SqlQueryRaw<int>("EXEC sp_GetMaxControlNoSeq @CategoryCode, @MMYY",
        sqlCategoryCode, sqlMMYY)
    .AsEnumerable()
    .FirstOrDefault();

Important: You MUST call .AsEnumerable() to avoid composability errors.


---

‚úÖ Final Working GenerateControlNo Method

private string GenerateControlNo(string categoryCode)
{
    string mmyy = DateTime.Now.ToString("MMyy");

    var sqlCategoryCode = new SqlParameter("@CategoryCode", categoryCode);
    var sqlMMYY = new SqlParameter("@MMYY", mmyy);

    int maxSeq = _context.Database
        .SqlQueryRaw<int>("EXEC sp_GetMaxControlNoSeq @CategoryCode, @MMYY",
            sqlCategoryCode, sqlMMYY)
        .AsEnumerable()
        .FirstOrDefault();

    int newSeq = maxSeq + 1;
    string seqFormatted = newSeq.ToString("000");

    return $"{categoryCode}-{mmyy}-{seqFormatted}";
}


---

üí° Extra Step: Ensure tbl_Category has CategoryCode

If not added yet:

ALTER TABLE tbl_Category
ADD CategoryCode NVARCHAR(10);

Example values:

UPDATE tbl_Category SET CategoryCode = 'NT-AT' WHERE CategoryName = 'Network Tools';
UPDATE tbl_Category SET CategoryCode = 'IT-AT' WHERE CategoryName = 'IT Assets';


---

üéâ Your Errors Are Now Fully Fixed!

If you want, I can continue with:

‚úÖ Adding ControlNo in Edit + Index pages
‚úÖ Validations (prevent duplicate ControlNo)
‚úÖ Auto-generate CategoryCode based on CategoryName (optional)

Just tell me!

**

'Category' does not contain a definition for 'CategoryCode' and no accessible extension method 'CategoryCode' accepting a first argument of type 'Category' could be found (are you missing a using directive or an assembly reference?)

No overload for method 'SqlQuery' takes 3 arguments

**

Below is a clean, beginner-friendly implementation that adds automatic Control No generation when saving an Item in ASP.NET Core MVC 8 + EF Core + Stored Procedures**, using your required format:

> NT-AT-MMYY-###
‚Ä¢ The prefix NT-AT comes from the selected Category
‚Ä¢ MMYY = current month + year
‚Ä¢ ### = auto-increment per month and per category




---

‚úÖ 1. Add Column in tbl_Item

Add new column to SQL:

ALTER TABLE tbl_Item
ADD ControlNo NVARCHAR(20);


---

‚úÖ 2. Add Column in Item Model

public string ControlNo { get; set; } = string.Empty;


---

‚úÖ 3. Update Category Table (add Code Prefix)

To support NT-AT per category, we add a new column:

ALTER TABLE tbl_Category
ADD CategoryCode NVARCHAR(10);

Sample Data

UPDATE tbl_Category SET CategoryCode = 'NT-AT' WHERE CategoryName = 'Network Tools';
UPDATE tbl_Category SET CategoryCode = 'IT-AT' WHERE CategoryName = 'IT Assets';
UPDATE tbl_Category SET CategoryCode = 'EL-AT' WHERE CategoryName = 'Electronics';

So you can configure any code per category.


---

‚úÖ 4. Stored Procedure to Get Current Max Sequence

Create a stored procedure to get the current highest sequence for that month + category.

CREATE OR ALTER PROCEDURE sp_GetMaxControlNoSeq
    @CategoryCode NVARCHAR(10),
    @MMYY NVARCHAR(4)
AS
BEGIN
    SELECT ISNULL(
        MAX(CAST(RIGHT(ControlNo, 3) AS INT))
    , 0) AS MaxSeq
    FROM tbl_Item
    WHERE ControlNo LIKE @CategoryCode + '-' + @MMYY + '-%';
END


---

‚úÖ 5. Generate Control No in Controller (ItemController)

Add Method to Generate Control No

private string GenerateControlNo(string categoryCode)
{
    string mmyy = DateTime.Now.ToString("MMyy");

    // call stored procedure to get current max seq
    var sqlCategoryCode = new SqlParameter("@CategoryCode", categoryCode);
    var sqlMMYY = new SqlParameter("@MMYY", mmyy);

    int maxSeq = _context.Database
        .SqlQuery<int>("EXEC sp_GetMaxControlNoSeq @CategoryCode, @MMYY",
            sqlCategoryCode, sqlMMYY)
        .FirstOrDefault();

    int newSeq = maxSeq + 1;
    string seqFormatted = newSeq.ToString("000");

    return $"{categoryCode}-{mmyy}-{seqFormatted}";
}


---

‚úÖ 6. Apply Auto-Generated Control No When Saving Item

In POST Create:

[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Create(Item model)
{
    if (ModelState.IsValid)
    {
        // Get category to extract CategoryCode
        var category = _context.Categories
            .FirstOrDefault(c => c.CategoryID == model.CategoryID);

        if (category == null)
        {
            ModelState.AddModelError("", "Invalid Category.");
            LoadCategories();
            return View(model);
        }

        // Generate ControlNo
        model.ControlNo = GenerateControlNo(category.CategoryCode);

        // Save item via stored procedure
        var pName = new SqlParameter("@ItemName", model.ItemName);
        var pCategory = new SqlParameter("@CategoryID", model.CategoryID);
        var pQty = new SqlParameter("@Quantity", model.Quantity);
        var pStatus = new SqlParameter("@Status", model.Status);
        var pControl = new SqlParameter("@ControlNo", model.ControlNo);

        _context.Database.ExecuteSqlRaw(@"
            EXEC sp_InsertItem 
                @ItemName,
                @CategoryID,
                @Quantity,
                @Status,
                @ControlNo",
            pName, pCategory, pQty, pStatus, pControl
        );

        return RedirectToAction(nameof(Index));
    }

    LoadCategories();
    return View(model);
}


---

‚úÖ 7. Update Stored Procedure sp_InsertItem

Make sure it includes ControlNo:

CREATE OR ALTER PROCEDURE sp_InsertItem
    @ItemName NVARCHAR(150),
    @CategoryID INT,
    @Quantity INT,
    @Status NVARCHAR(50),
    @ControlNo NVARCHAR(20)
AS
BEGIN
    INSERT INTO tbl_Item (ItemName, CategoryID, Quantity, Status, ControlNo)
    VALUES (@ItemName, @CategoryID, @Quantity, @Status, @ControlNo);
END


---

üéâ FINAL RESULT (Example)

If CategoryCode = NT-AT
System date = December 2025 ‚Üí 1225
Last sequence = 005

Generated:

NT-AT-1225-006

Automatically generated when saving the item.


---

Want me to also:

‚úÖ Add ControlNo in Index table?
‚úÖ Add ControlNo in Edit + Details pages?
‚úÖ Make prefix dynamic (e.g., NT-IT, NT-CT)?

Just tell me!

**

Excellent ‚Äî you‚Äôre moving toward a smarter inventory design üëè

Let‚Äôs enhance your setup so that when a user selects a Category in the Item Create form,
üëâ the Quantity field automatically shows the default quantity from tbl_Category,
but only if the category‚Äôs UoM is "Pc".

We‚Äôll handle this both in SQL and ASP.NET Core MVC (Razor + jQuery).


---

‚öôÔ∏è 1Ô∏è‚É£ Update SQL Table

Modify tbl_Category:

ALTER TABLE tbl_Category
ADD Uom NVARCHAR(20),
    Quantity INT;

Example data:

UPDATE tbl_Category
SET Uom = 'Pc', Quantity = 1
WHERE CategoryName IN ('Mouse', 'Keyboard');

UPDATE tbl_Category
SET Uom = 'Box', Quantity = 10
WHERE CategoryName = 'Cable';

UPDATE tbl_Category
SET Uom = 'Unit', Quantity = 1
WHERE CategoryName IN ('Laptop', 'Monitor');


---

üß© 2Ô∏è‚É£ Update Category Model

In Models/Category.cs:

namespace ITItemInventory.Models
{
    public class Category
    {
        public int CategoryID { get; set; }
        public string CategoryName { get; set; } = string.Empty;
        public string Uom { get; set; } = string.Empty;
        public int Quantity { get; set; }
    }
}


---

üß† 3Ô∏è‚É£ Update Data Context

Your ApplicationDbContext.cs already has:

public DbSet<Category> Categories { get; set; }

No changes needed ‚Äî EF will map the new columns automatically.


---

‚öôÔ∏è 4Ô∏è‚É£ Update Controller: Load Categories

You already have:

private void LoadCategories()
{
    ViewBag.Categories = _context.Categories
        .FromSqlRaw("SELECT * FROM tbl_Category")
        .AsEnumerable()
        .ToList();
}

‚úÖ That‚Äôs still fine ‚Äî it loads Uom and Quantity too.


---

üß© 5Ô∏è‚É£ Update Create View (Views/Item/Create.cshtml)

We‚Äôll use JavaScript/jQuery to detect the selected category and
automatically fill the Quantity textbox if Uom == "Pc".

Updated Create.cshtml

@model ITItemInventory.Models.Item
@{
    var categories = (IEnumerable<ITItemInventory.Models.Category>)ViewBag.Categories;
}

<h2>Create Item</h2>

<form asp-action="Create" id="itemForm">
    <div class="form-group">
        <label>Item Name</label>
        <input asp-for="ItemName" class="form-control" />
    </div>

    <div class="form-group mt-2">
        <label>Category</label>
        <select asp-for="CategoryID" class="form-control" id="CategoryID"
                asp-items="@(new SelectList(categories, "CategoryID", "CategoryName"))">
            <option value="">-- Select Category --</option>
        </select>
    </div>

    <div class="form-group mt-2">
        <label>Quantity</label>
        <input asp-for="Quantity" class="form-control" id="Quantity" />
    </div>

    <div class="form-group mt-2">
        <label>Status</label>
        <input asp-for="Status" class="form-control" />
    </div>

    <button type="submit" class="btn btn-primary mt-3">Save</button>
</form>

<!-- Add this JavaScript section -->
@section Scripts {
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        // Prepare category data (JSON from Razor)
        var categories = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(categories));

        $('#CategoryID').on('change', function () {
            var selectedId = $(this).val();
            var selectedCategory = categories.find(c => c.categoryID == selectedId);

            if (selectedCategory) {
                if (selectedCategory.uom.toLowerCase() === "pc") {
                    // Automatically fill Quantity field with category's default quantity
                    $('#Quantity').val(selectedCategory.quantity);
                    $('#Quantity').prop('readonly', true);
                } else {
                    // Enable manual entry for non-"Pc" UoM
                    $('#Quantity').val('');
                    $('#Quantity').prop('readonly', false);
                }
            } else {
                $('#Quantity').val('');
                $('#Quantity').prop('readonly', false);
            }
        });
    </script>
}


---

üßÆ How It Works

1. When the page loads, it serializes your tbl_Category data to JSON.


2. When the user selects a category:

JavaScript checks its Uom.

If Uom == "Pc", the Quantity textbox auto-fills with the category‚Äôs default Quantity and becomes readonly.

Otherwise, the textbox clears and becomes editable.





---

‚úÖ Example Behavior

Category	UOM	Default Qty	Behavior

Mouse	Pc	1	Auto-fill ‚Äú1‚Äù and readonly
Cable	Box	10	Quantity field empty and editable
Laptop	Unit	1	Quantity editable



---

üß† Summary

Step	Description

1	Added Uom and Quantity columns to tbl_Category
2	Updated Category model
3	Loaded category data to ViewBag
4	Used jQuery to detect UOM type
5	Automatically filled quantity if UOM = ‚ÄúPc‚Äù



---

Would you like the Edit page (Edit.cshtml) to behave the same way ‚Äî
i.e. automatically show the default quantity and disable editing when Uom == "Pc"?

**


Excellent step forward üëè ‚Äî you‚Äôre now connecting tbl_Item and tbl_Category, which is how real inventory systems work!

Let‚Äôs walk through this step-by-step in your ASP.NET Core MVC + EF Core + Stored Procedure setup.


---

üéØ Goal

When creating or editing an Item,
you want to populate the ‚ÄúCategory‚Äù dropdown from the tbl_Category table.


---

üß± 1. SQL Setup

Create tbl_Category:

CREATE TABLE tbl_Category (
    CategoryID INT IDENTITY(1,1) PRIMARY KEY,
    CategoryName NVARCHAR(100)
);

Insert some sample data:

INSERT INTO tbl_Category (CategoryName)
VALUES ('Laptop'), ('Monitor'), ('Keyboard'), ('Mouse'), ('Cable');


---

‚öôÔ∏è 2. Add Model

In Models/Category.cs:

namespace ITItemInventory.Models
{
    public class Category
    {
        public int CategoryID { get; set; }
        public string CategoryName { get; set; } = string.Empty;
    }
}


---

üß© 3. Update Item Model

In Models/Item.cs, replace your Category string property
with a proper foreign key relationship:

namespace ITItemInventory.Models
{
    public class Item
    {
        public int ItemID { get; set; }
        public string ItemName { get; set; } = string.Empty;
        public int CategoryID { get; set; }   // FK
        public int Quantity { get; set; }
        public string Status { get; set; } = string.Empty;

        // Navigation property (optional)
        public Category? Category { get; set; }
    }
}


---

üß† 4. Modify SQL Stored Procedures

You‚Äôll now store the CategoryID instead of a text name.

‚úÖ Update your tbl_Item definition

CREATE TABLE tbl_Item (
    ItemID INT IDENTITY(1,1) PRIMARY KEY,
    ItemName NVARCHAR(100),
    CategoryID INT,
    Quantity INT,
    Status NVARCHAR(20),
    FOREIGN KEY (CategoryID) REFERENCES tbl_Category(CategoryID)
);


---

üßÆ Update your stored procedures

Insert

CREATE OR ALTER PROCEDURE sp_InsertItem
    @ItemName NVARCHAR(100),
    @CategoryID INT,
    @Quantity INT,
    @Status NVARCHAR(20)
AS
BEGIN
    INSERT INTO tbl_Item (ItemName, CategoryID, Quantity, Status)
    VALUES (@ItemName, @CategoryID, @Quantity, @Status);
END;

Update

CREATE OR ALTER PROCEDURE sp_UpdateItem
    @ItemID INT,
    @ItemName NVARCHAR(100),
    @CategoryID INT,
    @Quantity INT,
    @Status NVARCHAR(20)
AS
BEGIN
    UPDATE tbl_Item
    SET ItemName = @ItemName,
        CategoryID = @CategoryID,
        Quantity = @Quantity,
        Status = @Status
    WHERE ItemID = @ItemID;
END;

Get All (Join Category)

CREATE OR ALTER PROCEDURE sp_GetAllItems
AS
BEGIN
    SELECT i.ItemID, i.ItemName, i.Quantity, i.Status, 
           c.CategoryID, c.CategoryName
    FROM tbl_Item i
    INNER JOIN tbl_Category c ON i.CategoryID = c.CategoryID
    ORDER BY i.ItemID DESC;
END;

Get By ID

CREATE OR ALTER PROCEDURE sp_GetItemById
    @ItemID INT
AS
BEGIN
    SELECT i.ItemID, i.ItemName, i.Quantity, i.Status, 
           c.CategoryID, c.CategoryName
    FROM tbl_Item i
    INNER JOIN tbl_Category c ON i.CategoryID = c.CategoryID
    WHERE i.ItemID = @ItemID;
END;


---

‚öôÔ∏è 5. Update EF Core Context

In ApplicationDbContext.cs, add the new table:

public DbSet<Category> Categories { get; set; }


---

üß© 6. Update Controller (ItemController)

We‚Äôll load categories in ViewBag to populate a dropdown.

Add this helper method:

private void LoadCategories()
{
    ViewBag.Categories = _context.Categories
        .FromSqlRaw("SELECT * FROM tbl_Category")
        .AsEnumerable()
        .ToList();
}


---

Update Create GET:

public IActionResult Create()
{
    LoadCategories();
    return View();
}

Update Create POST:

[HttpPost]
public async Task<IActionResult> Create(Item item)
{
    if (ModelState.IsValid)
    {
        await _context.Database.ExecuteSqlRawAsync(
            "EXEC sp_InsertItem @ItemName, @CategoryID, @Quantity, @Status",
            new SqlParameter("@ItemName", item.ItemName),
            new SqlParameter("@CategoryID", item.CategoryID),
            new SqlParameter("@Quantity", item.Quantity),
            new SqlParameter("@Status", item.Status)
        );
        return RedirectToAction(nameof(Index));
    }

    LoadCategories();
    return View(item);
}


---

Update Edit GET:

public IActionResult Edit(int id)
{
    var item = _context.Items
        .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
        .AsEnumerable()
        .FirstOrDefault();

    if (item == null)
        return NotFound();

    LoadCategories();
    return View(item);
}


---

üßæ 7. Update Views

üß© Create.cshtml

@model ITItemInventory.Models.Item

<h2>Create Item</h2>

<form asp-action="Create">
    <div>
        <label>Item Name</label>
        <input asp-for="ItemName" class="form-control" />
    </div>

    <div>
        <label>Category</label>
        <select asp-for="CategoryID" class="form-control"
                asp-items="@(new SelectList(ViewBag.Categories, "CategoryID", "CategoryName"))">
            <option value="">-- Select Category --</option>
        </select>
    </div>

    <div>
        <label>Quantity</label>
        <input asp-for="Quantity" class="form-control" />
    </div>

    <div>
        <label>Status</label>
        <input asp-for="Status" class="form-control" />
    </div>

    <button type="submit" class="btn btn-primary mt-2">Save</button>
</form>


---

‚úèÔ∏è Edit.cshtml

(same dropdown as Create)

@model ITItemInventory.Models.Item

<h2>Edit Item</h2>

<form asp-action="Edit">
    <input type="hidden" asp-for="ItemID" />
    <div>
        <label>Item Name</label>
        <input asp-for="ItemName" class="form-control" />
    </div>

    <div>
        <label>Category</label>
        <select asp-for="CategoryID" class="form-control"
                asp-items="@(new SelectList(ViewBag.Categories, "CategoryID", "CategoryName", Model.CategoryID))">
            <option value="">-- Select Category --</option>
        </select>
    </div>

    <div>
        <label>Quantity</label>
        <input asp-for="Quantity" class="form-control" />
    </div>

    <div>
        <label>Status</label>
        <input asp-for="Status" class="form-control" />
    </div>

    <button type="submit" class="btn btn-primary mt-2">Update</button>
</form>


---

‚úÖ Result

Now when you go to:

/Item/Create ‚Üí the Category dropdown is populated from tbl_Category.

/Item/Edit ‚Üí it shows the selected category correctly.



---

üß† Summary

Feature	Source	Description

Categories	tbl_Category	Used to populate dropdown
Items	tbl_Item	References CategoryID (FK)
UI	Razor Dropdown	asp-items="SelectList(ViewBag.Categories, ...)"
Controller	LoadCategories()	Gets category data using SQL



---

Would you like me to extend this next step so that:

You can manage categories (CRUD for tbl_Category) with stored procedures too,

and connect it cleanly to your existing Item module?

**

Excellent catch üí°‚Äîthat‚Äôs a very common EF Core error when using FromSqlRaw with stored procedures that return results.

Let‚Äôs go step by step to fix it cleanly and clearly.


---

üß≠ Why the error happens

The error:

> InvalidOperationException: 'FromSql' or 'SqlQuery' was called with non-composable SQL and with a query composing over it.



appears when EF Core tries to ‚Äúcompose‚Äù a query on top of a stored procedure ‚Äî for example when you use:

await _context.Items
    .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
    .FirstOrDefaultAsync();

The .FirstOrDefaultAsync() tries to compose further SQL on top of EXEC, and stored procedures are non-composable.


---

‚úÖ Correct Fix

You can fix this by forcing EF to execute and materialize the result before applying LINQ methods, using AsEnumerable().

So replace your line with this:

var item = _context.Items
    .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
    .AsEnumerable() // <---- FIX
    .FirstOrDefault();

This will first execute the stored procedure, get the data into memory,
and then FirstOrDefault() works on the C# side (client-side enumeration).


---

üß© Updated Sections

In your Edit (GET):

public async Task<IActionResult> Edit(int id)
{
    var item = _context.Items
        .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
        .AsEnumerable()
        .FirstOrDefault();

    if (item == null)
        return NotFound();

    return View(item);
}

In your Delete (GET):

public async Task<IActionResult> Delete(int id)
{
    var item = _context.Items
        .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
        .AsEnumerable()
        .FirstOrDefault();

    if (item == null)
        return NotFound();

    return View(item);
}


---

üß† Quick Summary

Problem	Reason	Fix

InvalidOperationException with FromSqlRaw	EF Core tries to compose query over stored procedure	Add .AsEnumerable() before LINQ (e.g., FirstOrDefault())



---

‚úÖ Optional: Safer Async Version

If you want to keep it async-style, you can also do:

var item = await Task.Run(() =>
    _context.Items
        .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
        .AsEnumerable()
        .FirstOrDefault()
);

That keeps your controller fully asynchronous.


---

Would you like me to give you a clean full controller code (updated) with this fix and some small best-practice improvements (like proper validation and error handling)?

**

InvalidOperationException: 'FromSql' or 'SqlQuery' was called with non-composable SQL and with a query composing over it. Consider calling 'AsEnumerable' after the method to perform the composition on the client side.

**

Perfect üëç ‚Äî Let‚Äôs go step-by-step and make a beginner-friendly CRUD (Create, Read, Update, Delete) example for your IT Item Inventory Management using:

ASP.NET Core MVC 8

Entity Framework Core

Stored Procedures in SQL Server


We‚Äôll use a sample table named tbl_Item.


---

üß± 1. SQL Server Setup

First, create your table and stored procedures.

üß© Table

CREATE TABLE tbl_Item (
    ItemID INT IDENTITY(1,1) PRIMARY KEY,
    ItemName NVARCHAR(100),
    Category NVARCHAR(50),
    Quantity INT,
    Status NVARCHAR(20)
);


---

üßÆ Stored Procedures

1Ô∏è‚É£ Insert

CREATE PROCEDURE sp_InsertItem
    @ItemName NVARCHAR(100),
    @Category NVARCHAR(50),
    @Quantity INT,
    @Status NVARCHAR(20)
AS
BEGIN
    INSERT INTO tbl_Item (ItemName, Category, Quantity, Status)
    VALUES (@ItemName, @Category, @Quantity, @Status);
END;

2Ô∏è‚É£ Update

CREATE PROCEDURE sp_UpdateItem
    @ItemID INT,
    @ItemName NVARCHAR(100),
    @Category NVARCHAR(50),
    @Quantity INT,
    @Status NVARCHAR(20)
AS
BEGIN
    UPDATE tbl_Item
    SET ItemName = @ItemName,
        Category = @Category,
        Quantity = @Quantity,
        Status = @Status
    WHERE ItemID = @ItemID;
END;

3Ô∏è‚É£ Delete

CREATE PROCEDURE sp_DeleteItem
    @ItemID INT
AS
BEGIN
    DELETE FROM tbl_Item WHERE ItemID = @ItemID;
END;

4Ô∏è‚É£ Get All

CREATE PROCEDURE sp_GetAllItems
AS
BEGIN
    SELECT * FROM tbl_Item ORDER BY ItemID DESC;
END;

5Ô∏è‚É£ Get By ID

CREATE PROCEDURE sp_GetItemById
    @ItemID INT
AS
BEGIN
    SELECT * FROM tbl_Item WHERE ItemID = @ItemID;
END;


---

‚öôÔ∏è 2. Create ASP.NET Core MVC Project

In Visual Studio 2022 or CLI:

dotnet new mvc -n ITItemInventory
cd ITItemInventory


---

üß© 3. Add the Model

In Models/Item.cs:

namespace ITItemInventory.Models
{
    public class Item
    {
        public int ItemID { get; set; }
        public string ItemName { get; set; } = string.Empty;
        public string Category { get; set; } = string.Empty;
        public int Quantity { get; set; }
        public string Status { get; set; } = string.Empty;
    }
}


---

üß† 4. Setup EF Core Context

Install packages (if not yet):

dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools

Then create Data/ApplicationDbContext.cs:

using Microsoft.EntityFrameworkCore;
using ITItemInventory.Models;

namespace ITItemInventory.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<Item> Items { get; set; }

        // This will not create table directly since we are using stored procedures
    }
}


---

‚öôÔ∏è 5. Configure Connection String

In appsettings.json:

"ConnectionStrings": {
  "DefaultConnection": "Server=YOUR_SERVER;Database=ITItemDB;Trusted_Connection=True;TrustServerCertificate=True;"
}

In Program.cs:

using ITItemInventory.Data;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
}
app.UseStaticFiles();
app.UseRouting();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Item}/{action=Index}/{id?}");

app.Run();


---

üß© 6. Create Controller

In Controllers/ItemController.cs:

using ITItemInventory.Data;
using ITItemInventory.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;

namespace ITItemInventory.Controllers
{
    public class ItemController : Controller
    {
        private readonly ApplicationDbContext _context;

        public ItemController(ApplicationDbContext context)
        {
            _context = context;
        }

        // READ - List all items
        public async Task<IActionResult> Index()
        {
            var items = await _context.Items
                .FromSqlRaw("EXEC sp_GetAllItems")
                .ToListAsync();
            return View(items);
        }

        // CREATE - GET
        public IActionResult Create()
        {
            return View();
        }

        // CREATE - POST
        [HttpPost]
        public async Task<IActionResult> Create(Item item)
        {
            if (ModelState.IsValid)
            {
                await _context.Database.ExecuteSqlRawAsync(
                    "EXEC sp_InsertItem @ItemName, @Category, @Quantity, @Status",
                    new SqlParameter("@ItemName", item.ItemName),
                    new SqlParameter("@Category", item.Category),
                    new SqlParameter("@Quantity", item.Quantity),
                    new SqlParameter("@Status", item.Status)
                );
                return RedirectToAction(nameof(Index));
            }
            return View(item);
        }

        // EDIT - GET
        public async Task<IActionResult> Edit(int id)
        {
            var item = await _context.Items
                .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
                .FirstOrDefaultAsync();

            if (item == null)
                return NotFound();

            return View(item);
        }

        // EDIT - POST
        [HttpPost]
        public async Task<IActionResult> Edit(Item item)
        {
            if (ModelState.IsValid)
            {
                await _context.Database.ExecuteSqlRawAsync(
                    "EXEC sp_UpdateItem @ItemID, @ItemName, @Category, @Quantity, @Status",
                    new SqlParameter("@ItemID", item.ItemID),
                    new SqlParameter("@ItemName", item.ItemName),
                    new SqlParameter("@Category", item.Category),
                    new SqlParameter("@Quantity", item.Quantity),
                    new SqlParameter("@Status", item.Status)
                );
                return RedirectToAction(nameof(Index));
            }
            return View(item);
        }

        // DELETE - GET
        public async Task<IActionResult> Delete(int id)
        {
            var item = await _context.Items
                .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
                .FirstOrDefaultAsync();

            if (item == null)
                return NotFound();

            return View(item);
        }

        // DELETE - POST
        [HttpPost, ActionName("Delete")]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            await _context.Database.ExecuteSqlRawAsync(
                "EXEC sp_DeleteItem @ItemID",
                new SqlParameter("@ItemID", id)
            );
            return RedirectToAction(nameof(Index));
        }
    }
}


---

üßæ 7. Create Views (Razor)

Create folder Views/Item/ and add:

‚ûï Create.cshtml

@model ITItemInventory.Models.Item
<h2>Create Item</h2>

<form asp-action="Create">
    <div>
        <label>Item Name</label>
        <input asp-for="ItemName" class="form-control" />
    </div>
    <div>
        <label>Category</label>
        <input asp-for="Category" class="form-control" />
    </div>
    <div>
        <label>Quantity</label>
        <input asp-for="Quantity" class="form-control" />
    </div>
    <div>
        <label>Status</label>
        <input asp-for="Status" class="form-control" />
    </div>
    <button type="submit" class="btn btn-primary mt-2">Save</button>
</form>


---

üìã Index.cshtml

@model IEnumerable<ITItemInventory.Models.Item>
<h2>Item List</h2>

<a asp-action="Create" class="btn btn-success mb-2">Add Item</a>

<table class="table table-bordered">
    <thead>
        <tr>
            <th>ItemID</th>
            <th>Item Name</th>
            <th>Category</th>
            <th>Quantity</th>
            <th>Status</th>
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var item in Model)
        {
            <tr>
                <td>@item.ItemID</td>
                <td>@item.ItemName</td>
                <td>@item.Category</td>
                <td>@item.Quantity</td>
                <td>@item.Status</td>
                <td>
                    <a asp-action="Edit" asp-route-id="@item.ItemID" class="btn btn-warning btn-sm">Edit</a>
                    <a asp-action="Delete" asp-route-id="@item.ItemID" class="btn btn-danger btn-sm">Delete</a>
                </td>
            </tr>
        }
    </tbody>
</table>


---

‚úèÔ∏è Edit.cshtml

(Same as Create but with model data)

@model ITItemInventory.Models.Item
<h2>Edit Item</h2>

<form asp-action="Edit">
    <input type="hidden" asp-for="ItemID" />
    <div>
        <label>Item Name</label>
        <input asp-for="ItemName" class="form-control" />
    </div>
    <div>
        <label>Category</label>
        <input asp-for="Category" class="form-control" />
    </div>
    <div>
        <label>Quantity</label>
        <input asp-for="Quantity" class="form-control" />
    </div>
    <div>
        <label>Status</label>
        <input asp-for="Status" class="form-control" />
    </div>
    <button type="submit" class="btn btn-primary mt-2">Update</button>
</form>


---

üóëÔ∏è Delete.cshtml

@model ITItemInventory.Models.Item
<h2>Delete Item</h2>

<div>
    <p>Are you sure you want to delete this item?</p>
    <h4>@Model.ItemName</h4>

    <form asp-action="Delete">
        <input type="hidden" asp-for="ItemID" />
        <button type="submit" class="btn btn-danger">Delete</button>
        <a asp-action="Index" class="btn btn-secondary">Cancel</a>
    </form>
</div>


---

‚úÖ 8. Run the App

1. Press F5 or run:

dotnet run


2. Visit:

https://localhost:5001/Item



You‚Äôll see your IT items CRUD running via stored procedures.


---

üß† Summary for Beginners

Action	Procedure Used	Method	Description

Index	sp_GetAllItems	GET	Displays all items
Create	sp_InsertItem	POST	Adds new item
Edit	sp_GetItemById, sp_UpdateItem	GET/POST	Updates existing item
Delete	sp_GetItemById, sp_DeleteItem	GET/POST	Deletes selected item



---

Would you like me to make this version use Bootstrap + DataTables for a more professional look (like your attendance system)?
