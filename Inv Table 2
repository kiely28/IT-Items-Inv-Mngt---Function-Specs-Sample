The error:

SqlNullValueException: Data is Null. This method or property cannot be called on Null values.

means that your stored procedure sp_GetAllItems is returning a NULL value in a column, but your Item model property is NOT nullable.

This ALWAYS happens when:

‚úî A column in tbl_items is NULL
‚ùå But your C# model property is not allowed to be NULL


---

‚úÖ 1. First: Show me your Item model

But before that, here is the fix.


---

‚úÖ 2. This is the most likely cause:

Your Item.cs probably looks like:

public string Category { get; set; }  // non-nullable
public string SerialNumber { get; set; } // non-nullable
public DateTime WarrantyExpiration { get; set; } // non-nullable
public int Quantity { get; set; } // non-nullable
public string Location { get; set; } // non-nullable

But your database has NULL in one of these columns.

So EF throws:

SqlNullValueException


---

‚úÖ 3. Solution: Make nullable properties nullable

Modify the model:

public class Item
{
    public int ItemID { get; set; }

    public string? ItemName { get; set; }
    public int? CategoryID { get; set; }
    public string? Category { get; set; }
    public string? SerialNumber { get; set; }

    public DateTime? WarrantyExpiration { get; set; }

    public int? Quantity { get; set; }

    public string? Status { get; set; }
    public string? Location { get; set; }

    public DateTime? AddedDate { get; set; }
    public string? ControlNo { get; set; }
}

‚úî Everything that can be NULL in the database must be nullable in your model (?).
‚úî If not, EF Core fails.


---

‚úÖ 4. Most common column causing this: WarrantyExpiration

You generate it only when adding items.

Any older rows probably have NULL warranty dates.

So this property MUST be:

public DateTime? WarrantyExpiration { get; set; }


---

‚úÖ 5. If the error still persists, find the exact null column

Insert a quick debug query:

var tableCheck = await _context.Items
    .FromSqlRaw("EXEC sp_GetAllItems")
    .ToListAsync();

Then check each row for NULL fields that map to non-nullable model properties.


---

üü• IMPORTANT: Your stored procedure might not return all fields

Make sure sp_GetAllItems returns exactly match model properties:

Example expected columns:

ItemID
ItemName
CategoryID
Category
Quantity
Status
SerialNumber
WarrantyExpiration
Location
AddedDate
ControlNo

If even one column that EF expects is missing or NULL, your model must allow null values.


---

üëç Send me your Item.cs and I will fix it perfectly.

**

Code: 

using Microsoft.AspNetCore.Mvc;
using Microsoft.Data.SqlClient;
using WebApplication2.Data;
using WebApplication2.Models;
using Microsoft.EntityFrameworkCore;

namespace WebApplication2.Controllers
{
    public class ItemController : Controller
    {
        private readonly ApplicationDbContext _context;

        public ItemController(ApplicationDbContext context)
        {
            _context = context;
        }

        // READ - List all items
        public async Task<IActionResult> Index()
        {
            var items = await _context.Items
                .FromSqlRaw("EXEC sp_GetAllItems")
                .ToListAsync();
            return View(items);
        }

        // CREATE - GET
        public IActionResult Create()
        {
            LoadCategories();
            return View();
        }

        // CREATE - POST
        [HttpPost]
        //public async Task<IActionResult> Create(Item item)
        //{
        //    if (ModelState.IsValid)
        //    {
        //        await _context.Database.ExecuteSqlRawAsync(
        //            "EXEC sp_InsertItem @ItemName, @CategoryID, @Quantity, @Status",
        //            new SqlParameter("@ItemName", item.ItemName),
        //            new SqlParameter("@CategoryID", item.CategoryID),
        //            new SqlParameter("@Quantity", item.Quantity),
        //            new SqlParameter("@Status", item.Status)
        //        );
        //        return RedirectToAction(nameof(Index));
        //    }
        //    LoadCategories();
        //    return View(item);
        //}
        [ValidateAntiForgeryToken]
        //public IActionResult Create(Item model)
        //{
        //    if (ModelState.IsValid)
        //    {
        //        // Get category to extract CategoryCode
        //        var category = _context.Categories
        //            .FirstOrDefault(c => c.CategoryID == model.CategoryID);

        //        if (category == null)
        //        {
        //            ModelState.AddModelError("", "Invalid Category.");
        //            LoadCategories();
        //            return View(model);
        //        }

        //        // Generate ControlNo
        //        model.ControlNo = GenerateControlNo(category.CategoryCode);

        //        // Save item via stored procedure
        //        var pName = new SqlParameter("@ItemName", model.ItemName);
        //        var pCategory = new SqlParameter("@CategoryID", model.CategoryID);
        //        var pQty = new SqlParameter("@Quantity", model.Quantity);
        //        var pStatus = new SqlParameter("@Status", model.Status);
        //        var pControl = new SqlParameter("@ControlNo", model.ControlNo);

        //        _context.Database.ExecuteSqlRaw(@"
        //    EXEC sp_InsertItem 
        //        @ItemName,
        //        @CategoryID,
        //        @Quantity,
        //        @Status,
        //        @ControlNo",
        //            pName, pCategory, pQty, pStatus, pControl
        //        );

        //        return RedirectToAction(nameof(Index));
        //    }

        //    LoadCategories();
        //    return View(model);
        //}

        public IActionResult Create(Item model)
        {
            if (ModelState.IsValid)
            {
                // 1. Get Category (to get validity months & prefix)
                var category = _context.Categories
                    .FirstOrDefault(c => c.CategoryID == model.CategoryID);

                if (category == null)
                {
                    ModelState.AddModelError("", "Invalid Category.");
                    LoadCategories();
                    return View(model);
                }

                // 2. Generate ControlNo
                model.ControlNo = GenerateControlNo(category.CategoryCode);

                // 3. Set Added Date (today)
                model.AddedDate = DateTime.Now;

                // 4. Compute Warranty Expiration Date
                model.WarrantyExpiration = model.AddedDate.AddMonths(category.ValidityMonths);

                // 5. Save via Stored Procedure
                var pName = new SqlParameter("@ItemName", model.ItemName);
                var pCat = new SqlParameter("@CategoryID", model.CategoryID);
                var pQty = new SqlParameter("@Quantity", model.Quantity);
                var pStatus = new SqlParameter("@Status", model.Status);
                var pCtrl = new SqlParameter("@ControlNo", model.ControlNo);
                var pDate = new SqlParameter("@AddedDate", model.AddedDate);
                var pExp = new SqlParameter("@WarrantyExpiration", model.WarrantyExpiration);

                _context.Database.ExecuteSqlRaw(@"
            EXEC sp_InsertItem 
                @ItemName,
                @CategoryID,
                @Quantity,
                @Status,
                @ControlNo,
                @AddedDate,
                @WarrantyExpiration",
                    pName, pCat, pQty, pStatus, pCtrl, pDate, pExp
                );

                return RedirectToAction(nameof(Index));
            }

            LoadCategories();
            return View(model);
        }


        // EDIT - GET
        public async Task<IActionResult> Edit(int id)
        {
            //    var item = await _context.Items
            //        .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
            //        .FirstOrDefaultAsync();
            var item = _context.Items
                  .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
                  .AsEnumerable()
                  .FirstOrDefault();

            if (item == null)
                return NotFound();

            LoadCategories();
            return View(item);
        }
        //public async Task<IActionResult> Edit(int id)
        //{
        //    //var item = await _context.Items
        //    //    .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
        //    //    .FirstOrDefaultAsync();
        //    var item = await Task.Run(() =>
        //        _context.Items
        //            .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
        //            .AsEnumerable()
        //            .FirstOrDefault()
        //    );

        //    if (item == null)
        //        return NotFound();

        //    return View(item);
        //}

        // EDIT - POST
        [HttpPost]
        public async Task<IActionResult> Edit(Item item)
        {
            if (ModelState.IsValid)
            {
                await _context.Database.ExecuteSqlRawAsync(
                    "EXEC sp_UpdateItem @ItemID, @ItemName, @CategoryID, @Quantity, @Status",
                    new SqlParameter("@ItemID", item.ItemID),
                    new SqlParameter("@ItemName", item.ItemName),
                    new SqlParameter("@CategoryID", item.CategoryID),
                    new SqlParameter("@Quantity", item.Quantity),
                    new SqlParameter("@Status", item.Status)
                );
                return RedirectToAction(nameof(Index));
            }
            return View(item);
        }

        // DELETE - GET
        public async Task<IActionResult> Delete(int id)
        {
            //var item = await _context.Items
            //    .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
            //    .FirstOrDefaultAsync();
            //var item = await Task.Run(() =>
            //    _context.Items
            //        .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
            //        .AsEnumerable()
            //        .FirstOrDefault()
            //);
            var item = _context.Items
                .FromSqlRaw("EXEC sp_GetItemById @ItemID", new SqlParameter("@ItemID", id))
                .AsEnumerable()
                .FirstOrDefault();

            if (item == null)
                return NotFound();

            return View(item);
        }

        // DELETE - POST
        [HttpPost, ActionName("Delete")]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            await _context.Database.ExecuteSqlRawAsync(
                "EXEC sp_DeleteItem @ItemID",
                new SqlParameter("@ItemID", id)
            );
            return RedirectToAction(nameof(Index));
        }
        private void LoadCategories()
        {
            ViewBag.Categories = _context.Categories
                .FromSqlRaw("SELECT * FROM tbl_Category")
                .AsEnumerable()
                .ToList();
        }


        private string GenerateControlNo(string categoryCode)
        {
            string mmyy = DateTime.Now.ToString("MMyy");

            // call stored procedure to get current max seq
            var sqlCategoryCode = new SqlParameter("@CategoryCode", categoryCode);
            var sqlMMYY = new SqlParameter("@MMYY", mmyy);

            int maxSeq = _context.Database
                .SqlQueryRaw<int>("EXEC sp_GetMaxControlNoSeq @CategoryCode, @MMYY",
                    sqlCategoryCode, sqlMMYY)
                .AsEnumerable()
                .FirstOrDefault();

            int newSeq = maxSeq + 1;
            string seqFormatted = newSeq.ToString("000");

            return $"{categoryCode}-{mmyy}-{seqFormatted}";
        }




    }


}


this line : var items = await _context.Items
Error: SqlNullValueException: Data is Null. This method or property cannot be called on Null values.

**

You are getting the error because Razor views in ASP.NET Core MVC 8 no longer expose Request directly unless you reference it from the correct scope.

To fix it, you must use:

‚úî Context.Request
OR
‚úî ViewContext.HttpContext.Request


---

‚úÖ Simplest Fix

Replace your line:

<option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">

With:

<option value="@loc" selected="@(Context.Request.Query["locationFilter"] == loc)">

‚úî Works in MVC 6‚Äì8
‚úî No extra code needed


---

üü¶ Full Corrected Code Block

<option value="@loc" selected="@(Context.Request.Query["locationFilter"] == loc)">
    @loc
</option>


---

üü© Alternative Working Version

<option value="@loc" selected="@(ViewContext.HttpContext.Request.Query["locationFilter"] == loc)">
    @loc
</option>


---

üüß Even Cleaner Way (Recommended)

Instead of checking the query directly inside Razor, you can pass the selected filter from the controller:

Controller

ViewBag.SelectedLocation = locationFilter;

View

<option value="@loc" selected="@(ViewBag.SelectedLocation == loc)">
    @loc
</option>

This avoids direct Request access and keeps Razor clean.


---

üéâ Your dropdown will now work and pre-select the location properly.

If you want, I can also add:

‚úî Category filter
‚úî Warranty expired filter
‚úî Search box
‚úî Export to Excel/PDF

Just tell me!

**


Code:

@model List<Item>

<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" />

<link rel="stylesheet"
      href="https://cdn.datatables.net/1.13.6/css/dataTables.semanticui.min.css" />

<div class="ui container">
    <h2 class="ui header">Inventory List</h2>

    <form method="get" asp-action="Index" class="ui form">
        <div class="field">
            <label>Filter by Location</label>

            <select name="locationFilter" class="ui dropdown" onchange="this.form.submit()">
                <option value="">-- All Locations --</option>

                @foreach (var loc in ViewBag.Locations)
                {
                    <option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">
                        @loc
                    </option>
                }
            </select>
        </div>
    </form>

    <table id="inventoryTable" class="ui celled table">
        <thead>
            <tr>
                <th>Item Name</th>
                <th>Category</th>
                <th>Serial Number</th>
                <th>Warranty Expiration</th>
                <th>Qty</th>
                <th>Location</th>
            </tr>
        </thead>

        <tbody>
            @foreach (var item in Model)
            {
                <tr>
                    <td>@item.ItemName</td>
                    <td>@item.Category</td>
                    <td>@item.SerialNumber</td>
                    <td>@item.WarrantyExpiration?.ToString("yyyy-MM-dd")</td>
                    <td>@item.Quantity</td>
                    <td>@item.Location</td>
                </tr>
            }
        </tbody>
    </table>
</div>

<script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"></script>

<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/dataTables.semanticui.min.js"></script>

<script>
    $(document).ready(function () {
        $('#inventoryTable').DataTable();
        $('.ui.dropdown').dropdown();
    });
</script>

This line:  <option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">

Error: The name 'Request' does not exist in the current context

**

You are getting this error because Database.SqlQuery<T>() is only available in EF Core 8, but only when your DbContext inherits from:

‚úî DbContext
NOT from IdentityDbContext, ApiAuthorizationDbContext, or other custom context types.

OR your project may be missing:

using Microsoft.EntityFrameworkCore;


---

‚úÖ Fix Below ‚Äî Use EF Core 8 Correct Methods

EF Core 8 replaces Database.SqlQuery<T>() with Database.SqlQueryRaw<T>().


---

‚úÖ 1. Replace GetLocations() with Correct EF Core 8 Syntax

üî• Correct Working Code

public async Task<List<string>> GetLocations()
{
    return await this.Database
        .SqlQueryRaw<string>("EXEC sp_getLocations")
        .ToListAsync();
}


---

‚ùó If Your DbContext Inherits from IdentityDbContext

Add this using:

using Microsoft.EntityFrameworkCore;

Make sure your context header looks like:

public class ApplicationDbContext : IdentityDbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<Item> Items { get; set; }
}

‚úî It still has .Database
‚ùó Unless your file is missing the EF Core namespace.


---

üî• 2. Full Updated ApplicationDbContext.cs

using Microsoft.EntityFrameworkCore;
using Microsoft.Data.SqlClient;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<Item> Items { get; set; }

    // Inventory List SP
    public async Task<List<Item>> GetInventoryList(string location)
    {
        var param = new SqlParameter("@Location", 
            string.IsNullOrEmpty(location) ? DBNull.Value : location);

        return await Items
            .FromSqlRaw("EXEC sp_getInventoryList @Location", param)
            .ToListAsync();
    }

    // Locations SP
    public async Task<List<string>> GetLocations()
    {
        return await this.Database
            .SqlQueryRaw<string>("EXEC sp_getLocations")
            .ToListAsync();
    }
}


---

‚úî Common Causes of This Error

1. Missing using

using Microsoft.EntityFrameworkCore;

2. Wrong context type

Your DbContext must inherit:

public class ApplicationDbContext : DbContext

Or:

public class ApplicationDbContext : IdentityDbContext

Both support .Database

3. Wrong project reference

Make sure the project references:

Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.SqlServer


---

If you want, I can verify your ApplicationDbContext.cs and fix it 100%.

Just paste it here.

**


'ApplicationDbContext' does not contain a definition for 'Database' and no accessible extension method 'Database' accepting a first argument of type 'ApplicationDbContext' could be found (are you missing a using directive or an assembly reference?)

**

Below is a complete and clean module for Inventory List using:

‚úî ASP.NET Core MVC 8
‚úî EF Core
‚úî SQL Server Stored Procedures
‚úî DataTables + Semantic UI
‚úî Location dropdown filter
‚úî Loads data from tbl_items


---

‚úÖ 1. SQL Server Stored Procedures

a. SP_GetLocations

Returns DISTINCT locations:

CREATE PROCEDURE sp_getLocations
AS
BEGIN
    SELECT DISTINCT Location 
    FROM tbl_items
    WHERE Location IS NOT NULL AND Location <> ''
    ORDER BY Location;
END


---

b. SP_GetInventoryList

Supports filtering by location:

CREATE PROCEDURE sp_getInventoryList
    @Location NVARCHAR(100) = NULL
AS
BEGIN
    SELECT 
        ItemId,
        ItemName,
        Category,
        SerialNumber,
        WarrantyExpiration,
        Quantity,
        Location
    FROM tbl_items
    WHERE (@Location IS NULL OR Location = @Location)
    ORDER BY ItemName;
END


---

‚úÖ 2. Model: Item.cs

public class Item
{
    public int ItemId { get; set; }
    public string ItemName { get; set; }
    public string Category { get; set; }
    public string SerialNumber { get; set; }
    public DateTime? WarrantyExpiration { get; set; }
    public int Quantity { get; set; }
    public string Location { get; set; }
}


---

‚úÖ 3. DbContext (ApplicationDbContext.cs)

Add to your context:

public DbSet<Item> Items { get; set; }

public async Task<List<Item>> GetInventoryList(string location)
{
    var param = new SqlParameter("@Location", string.IsNullOrEmpty(location) ? DBNull.Value : location);

    return await Items.FromSqlRaw("EXEC sp_getInventoryList @Location", param).ToListAsync();
}

public async Task<List<string>> GetLocations()
{
    return await this.Database.SqlQuery<string>("EXEC sp_getLocations").ToListAsync();
}


---

‚úÖ 4. Controller: InventoryController.cs

using Microsoft.AspNetCore.Mvc;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;

public class InventoryController : Controller
{
    private readonly ApplicationDbContext _context;

    public InventoryController(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<IActionResult> Index(string locationFilter)
    {
        // Load locations for dropdown
        ViewBag.Locations = await _context.GetLocations();

        // Load inventory list
        var items = await _context.GetInventoryList(locationFilter);

        return View(items);
    }
}


---

‚úÖ 5. View: Index.cshtml (Inventory List)

Includes:

‚úî Dropdown filter
‚úî Auto-submit on change
‚úî Semantic UI + DataTables table

Make sure you include Semantic UI + DataTables scripts.


---

@model List<Item>

<link rel="stylesheet" 
      href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" />

<link rel="stylesheet" 
      href="https://cdn.datatables.net/1.13.6/css/dataTables.semanticui.min.css" />

<div class="ui container">
    <h2 class="ui header">Inventory List</h2>

    <form method="get" asp-action="Index" class="ui form">
        <div class="field">
            <label>Filter by Location</label>

            <select name="locationFilter" class="ui dropdown" onchange="this.form.submit()">
                <option value="">-- All Locations --</option>

                @foreach (var loc in ViewBag.Locations)
                {
                    <option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">
                        @loc
                    </option>
                }
            </select>
        </div>
    </form>

    <table id="inventoryTable" class="ui celled table">
        <thead>
            <tr>
                <th>Item Name</th>
                <th>Category</th>
                <th>Serial Number</th>
                <th>Warranty Expiration</th>
                <th>Qty</th>
                <th>Location</th>
            </tr>
        </thead>

        <tbody>
            @foreach (var item in Model)
            {
                <tr>
                    <td>@item.ItemName</td>
                    <td>@item.Category</td>
                    <td>@item.SerialNumber</td>
                    <td>@item.WarrantyExpiration?.ToString("yyyy-MM-dd")</td>
                    <td>@item.Quantity</td>
                    <td>@item.Location</td>
                </tr>
            }
        </tbody>
    </table>
</div>

<script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"></script>

<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/dataTables.semanticui.min.js"></script>

<script>
    $(document).ready(function () {
        $('#inventoryTable').DataTable();
        $('.ui.dropdown').dropdown();
    });
</script>


---

‚úÖ 6. Folder Structure

Controllers/
   InventoryController.cs

Views/
   Inventory/
      Index.cshtml

Models/
   Item.cs

Data/
   ApplicationDbContext.cs


---

üéâ DONE!

You now have a complete Inventory List Module with:

‚úî Stored procedures
‚úî Location dropdown
‚úî DataTables + Semantic UI
‚úî MVC 8 + EF Core


---

If you want, I can also generate:

üìå Export to Excel / PDF
üìå Edit / Delete buttons
üìå Modal popup for item details
üìå Filtering by category, warranty expired, etc
üìå Server-side DataTables

Would you like to continue?
