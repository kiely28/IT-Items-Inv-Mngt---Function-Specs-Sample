You are getting the error because Razor views in ASP.NET Core MVC 8 no longer expose Request directly unless you reference it from the correct scope.

To fix it, you must use:

‚úî Context.Request
OR
‚úî ViewContext.HttpContext.Request


---

‚úÖ Simplest Fix

Replace your line:

<option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">

With:

<option value="@loc" selected="@(Context.Request.Query["locationFilter"] == loc)">

‚úî Works in MVC 6‚Äì8
‚úî No extra code needed


---

üü¶ Full Corrected Code Block

<option value="@loc" selected="@(Context.Request.Query["locationFilter"] == loc)">
    @loc
</option>


---

üü© Alternative Working Version

<option value="@loc" selected="@(ViewContext.HttpContext.Request.Query["locationFilter"] == loc)">
    @loc
</option>


---

üüß Even Cleaner Way (Recommended)

Instead of checking the query directly inside Razor, you can pass the selected filter from the controller:

Controller

ViewBag.SelectedLocation = locationFilter;

View

<option value="@loc" selected="@(ViewBag.SelectedLocation == loc)">
    @loc
</option>

This avoids direct Request access and keeps Razor clean.


---

üéâ Your dropdown will now work and pre-select the location properly.

If you want, I can also add:

‚úî Category filter
‚úî Warranty expired filter
‚úî Search box
‚úî Export to Excel/PDF

Just tell me!

**


Code:

@model List<Item>

<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" />

<link rel="stylesheet"
      href="https://cdn.datatables.net/1.13.6/css/dataTables.semanticui.min.css" />

<div class="ui container">
    <h2 class="ui header">Inventory List</h2>

    <form method="get" asp-action="Index" class="ui form">
        <div class="field">
            <label>Filter by Location</label>

            <select name="locationFilter" class="ui dropdown" onchange="this.form.submit()">
                <option value="">-- All Locations --</option>

                @foreach (var loc in ViewBag.Locations)
                {
                    <option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">
                        @loc
                    </option>
                }
            </select>
        </div>
    </form>

    <table id="inventoryTable" class="ui celled table">
        <thead>
            <tr>
                <th>Item Name</th>
                <th>Category</th>
                <th>Serial Number</th>
                <th>Warranty Expiration</th>
                <th>Qty</th>
                <th>Location</th>
            </tr>
        </thead>

        <tbody>
            @foreach (var item in Model)
            {
                <tr>
                    <td>@item.ItemName</td>
                    <td>@item.Category</td>
                    <td>@item.SerialNumber</td>
                    <td>@item.WarrantyExpiration?.ToString("yyyy-MM-dd")</td>
                    <td>@item.Quantity</td>
                    <td>@item.Location</td>
                </tr>
            }
        </tbody>
    </table>
</div>

<script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"></script>

<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/dataTables.semanticui.min.js"></script>

<script>
    $(document).ready(function () {
        $('#inventoryTable').DataTable();
        $('.ui.dropdown').dropdown();
    });
</script>

This line:  <option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">

Error: The name 'Request' does not exist in the current context

**

You are getting this error because Database.SqlQuery<T>() is only available in EF Core 8, but only when your DbContext inherits from:

‚úî DbContext
NOT from IdentityDbContext, ApiAuthorizationDbContext, or other custom context types.

OR your project may be missing:

using Microsoft.EntityFrameworkCore;


---

‚úÖ Fix Below ‚Äî Use EF Core 8 Correct Methods

EF Core 8 replaces Database.SqlQuery<T>() with Database.SqlQueryRaw<T>().


---

‚úÖ 1. Replace GetLocations() with Correct EF Core 8 Syntax

üî• Correct Working Code

public async Task<List<string>> GetLocations()
{
    return await this.Database
        .SqlQueryRaw<string>("EXEC sp_getLocations")
        .ToListAsync();
}


---

‚ùó If Your DbContext Inherits from IdentityDbContext

Add this using:

using Microsoft.EntityFrameworkCore;

Make sure your context header looks like:

public class ApplicationDbContext : IdentityDbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<Item> Items { get; set; }
}

‚úî It still has .Database
‚ùó Unless your file is missing the EF Core namespace.


---

üî• 2. Full Updated ApplicationDbContext.cs

using Microsoft.EntityFrameworkCore;
using Microsoft.Data.SqlClient;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<Item> Items { get; set; }

    // Inventory List SP
    public async Task<List<Item>> GetInventoryList(string location)
    {
        var param = new SqlParameter("@Location", 
            string.IsNullOrEmpty(location) ? DBNull.Value : location);

        return await Items
            .FromSqlRaw("EXEC sp_getInventoryList @Location", param)
            .ToListAsync();
    }

    // Locations SP
    public async Task<List<string>> GetLocations()
    {
        return await this.Database
            .SqlQueryRaw<string>("EXEC sp_getLocations")
            .ToListAsync();
    }
}


---

‚úî Common Causes of This Error

1. Missing using

using Microsoft.EntityFrameworkCore;

2. Wrong context type

Your DbContext must inherit:

public class ApplicationDbContext : DbContext

Or:

public class ApplicationDbContext : IdentityDbContext

Both support .Database

3. Wrong project reference

Make sure the project references:

Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.SqlServer


---

If you want, I can verify your ApplicationDbContext.cs and fix it 100%.

Just paste it here.

**


'ApplicationDbContext' does not contain a definition for 'Database' and no accessible extension method 'Database' accepting a first argument of type 'ApplicationDbContext' could be found (are you missing a using directive or an assembly reference?)

**

Below is a complete and clean module for Inventory List using:

‚úî ASP.NET Core MVC 8
‚úî EF Core
‚úî SQL Server Stored Procedures
‚úî DataTables + Semantic UI
‚úî Location dropdown filter
‚úî Loads data from tbl_items


---

‚úÖ 1. SQL Server Stored Procedures

a. SP_GetLocations

Returns DISTINCT locations:

CREATE PROCEDURE sp_getLocations
AS
BEGIN
    SELECT DISTINCT Location 
    FROM tbl_items
    WHERE Location IS NOT NULL AND Location <> ''
    ORDER BY Location;
END


---

b. SP_GetInventoryList

Supports filtering by location:

CREATE PROCEDURE sp_getInventoryList
    @Location NVARCHAR(100) = NULL
AS
BEGIN
    SELECT 
        ItemId,
        ItemName,
        Category,
        SerialNumber,
        WarrantyExpiration,
        Quantity,
        Location
    FROM tbl_items
    WHERE (@Location IS NULL OR Location = @Location)
    ORDER BY ItemName;
END


---

‚úÖ 2. Model: Item.cs

public class Item
{
    public int ItemId { get; set; }
    public string ItemName { get; set; }
    public string Category { get; set; }
    public string SerialNumber { get; set; }
    public DateTime? WarrantyExpiration { get; set; }
    public int Quantity { get; set; }
    public string Location { get; set; }
}


---

‚úÖ 3. DbContext (ApplicationDbContext.cs)

Add to your context:

public DbSet<Item> Items { get; set; }

public async Task<List<Item>> GetInventoryList(string location)
{
    var param = new SqlParameter("@Location", string.IsNullOrEmpty(location) ? DBNull.Value : location);

    return await Items.FromSqlRaw("EXEC sp_getInventoryList @Location", param).ToListAsync();
}

public async Task<List<string>> GetLocations()
{
    return await this.Database.SqlQuery<string>("EXEC sp_getLocations").ToListAsync();
}


---

‚úÖ 4. Controller: InventoryController.cs

using Microsoft.AspNetCore.Mvc;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;

public class InventoryController : Controller
{
    private readonly ApplicationDbContext _context;

    public InventoryController(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<IActionResult> Index(string locationFilter)
    {
        // Load locations for dropdown
        ViewBag.Locations = await _context.GetLocations();

        // Load inventory list
        var items = await _context.GetInventoryList(locationFilter);

        return View(items);
    }
}


---

‚úÖ 5. View: Index.cshtml (Inventory List)

Includes:

‚úî Dropdown filter
‚úî Auto-submit on change
‚úî Semantic UI + DataTables table

Make sure you include Semantic UI + DataTables scripts.


---

@model List<Item>

<link rel="stylesheet" 
      href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" />

<link rel="stylesheet" 
      href="https://cdn.datatables.net/1.13.6/css/dataTables.semanticui.min.css" />

<div class="ui container">
    <h2 class="ui header">Inventory List</h2>

    <form method="get" asp-action="Index" class="ui form">
        <div class="field">
            <label>Filter by Location</label>

            <select name="locationFilter" class="ui dropdown" onchange="this.form.submit()">
                <option value="">-- All Locations --</option>

                @foreach (var loc in ViewBag.Locations)
                {
                    <option value="@loc" selected="@(Request.Query["locationFilter"] == loc)">
                        @loc
                    </option>
                }
            </select>
        </div>
    </form>

    <table id="inventoryTable" class="ui celled table">
        <thead>
            <tr>
                <th>Item Name</th>
                <th>Category</th>
                <th>Serial Number</th>
                <th>Warranty Expiration</th>
                <th>Qty</th>
                <th>Location</th>
            </tr>
        </thead>

        <tbody>
            @foreach (var item in Model)
            {
                <tr>
                    <td>@item.ItemName</td>
                    <td>@item.Category</td>
                    <td>@item.SerialNumber</td>
                    <td>@item.WarrantyExpiration?.ToString("yyyy-MM-dd")</td>
                    <td>@item.Quantity</td>
                    <td>@item.Location</td>
                </tr>
            }
        </tbody>
    </table>
</div>

<script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"></script>

<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/dataTables.semanticui.min.js"></script>

<script>
    $(document).ready(function () {
        $('#inventoryTable').DataTable();
        $('.ui.dropdown').dropdown();
    });
</script>


---

‚úÖ 6. Folder Structure

Controllers/
   InventoryController.cs

Views/
   Inventory/
      Index.cshtml

Models/
   Item.cs

Data/
   ApplicationDbContext.cs


---

üéâ DONE!

You now have a complete Inventory List Module with:

‚úî Stored procedures
‚úî Location dropdown
‚úî DataTables + Semantic UI
‚úî MVC 8 + EF Core


---

If you want, I can also generate:

üìå Export to Excel / PDF
üìå Edit / Delete buttons
üìå Modal popup for item details
üìå Filtering by category, warranty expired, etc
üìå Server-side DataTables

Would you like to continue?
