This error is very clear once you know where to look ğŸ‘
Itâ€™s caused by a type mismatch between your dropdown value and your model property.


---

ğŸ”´ The Error

InvalidCastException:
Unable to cast object of type 'System.Int32' to type 'System.String'

ğŸ‘‰ Meaning:
.NET is receiving an INT value but trying to assign it to a string property.


---

ğŸ” Root Cause (Your Case)

You now have Category.Id (int) in tbl_category, but your Student model still uses string:

// Student.cs
public string Category { get; set; }   // âŒ string

But your dropdown is likely posting:

<option value="@item.Id">...</option>  // âœ… int

â¡ï¸ MVC tries to assign int â†’ string
â¡ï¸ âŒ InvalidCastException


---

âœ… CORRECT FIX (BEST PRACTICE)

âœ” Store the CategoryId (int), not CategoryName

This is the professional & database-correct approach.


---

1ï¸âƒ£ Update Student Model

public class Student
{
    public int Id { get; set; }

    public string Name { get; set; }

    public int Age { get; set; }

    // FK to Category
    public int CategoryId { get; set; }
}

âŒ Remove string Category
âœ… Use int CategoryId


---

2ï¸âƒ£ Update Students Table

ALTER TABLE Students
ADD CategoryId INT;

(Optional FK)

ALTER TABLE Students
ADD CONSTRAINT FK_Students_Category
FOREIGN KEY (CategoryId) REFERENCES tbl_category(Id);


---

3ï¸âƒ£ Update Stored Procedures

INSERT

ALTER PROCEDURE sp_Students_Insert
    @Name NVARCHAR(100),
    @Age INT,
    @CategoryId INT
AS
BEGIN
    SET NOCOUNT ON;

    INSERT INTO Students (Name, Age, CategoryId)
    VALUES (@Name, @Age, @CategoryId)
END
GO


---

UPDATE

ALTER PROCEDURE sp_Students_Update
    @Id INT,
    @Name NVARCHAR(100),
    @Age INT,
    @CategoryId INT
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE Students
    SET Name = @Name,
        Age = @Age,
        CategoryId = @CategoryId
    WHERE Id = @Id
END
GO


---

4ï¸âƒ£ Update AppDbContext

public async Task InsertStudentAsync(Student student)
{
    await Database.ExecuteSqlRawAsync(
        "EXEC sp_Students_Insert @Name, @Age, @CategoryId",
        new SqlParameter("@Name", student.Name),
        new SqlParameter("@Age", student.Age),
        new SqlParameter("@CategoryId", student.CategoryId)
    );
}

public async Task UpdateStudentAsync(Student student)
{
    await Database.ExecuteSqlRawAsync(
        "EXEC sp_Students_Update @Id, @Name, @Age, @CategoryId",
        new SqlParameter("@Id", student.Id),
        new SqlParameter("@Name", student.Name),
        new SqlParameter("@Age", student.Age),
        new SqlParameter("@CategoryId", student.CategoryId)
    );
}


---

5ï¸âƒ£ Fix the Dropdown (IMPORTANT)

âœ… Use Id as value, bind to CategoryId

<select asp-for="CategoryId" class="form-control">
    <option value="">-- Select Category --</option>
    @foreach (var item in categories)
    {
        <option value="@item.Id">@item.CategoryName</option>
    }
</select>

âœ” int â†’ int
âœ” No casting error
âœ” Correct relational design


---

ğŸŸ¢ Alternative (NOT Recommended)

If you insist on storing CategoryName as string:

<option value="@item.CategoryName">@item.CategoryName</option>

But âŒ this breaks normalization
âŒ harder to maintain
âŒ bad for reporting


---

ğŸ† Final Recommendation (What You SHOULD Do)

âœ” Use CategoryId (INT)
âœ” Use FK relationship
âœ” Use dropdown value = Id
âœ” Display text = CategoryName

This is enterprise-grade design and exactly what youâ€™ll need later for:

Reports

Joins

Filters

Performance



---

ğŸš€ Want the Next Step?

I can help you:

âœ… Join CategoryName in sp_Students_GetAll

âœ… Display CategoryName in Index page

âœ… Convert to ViewModel (no ViewBag)

âœ… Apply same fix to Location / Department


Just tell me ğŸ‘



**

InvalidCastException: Unable to cast object of type 'System.Int32' to type 'System.String'.

**


This is a very common EF Core issue ğŸ‘ and the error message is actually telling you the exact fix.

Letâ€™s explain why it happens and then Iâ€™ll give you two correct solutions.
ğŸ‘‰ Choose Solution A (recommended) or Solution B (quick fix).


---

ğŸ”´ Why This Error Happens

You defined:

public DbSet<Category> Categories { get; set; }

EF Core assumes Category is a table entity, and every entity MUST have a primary key.

But your Category model:

public class Category
{
    public string CategoryName { get; set; }
}

âŒ No primary key
âŒ EF Core doesnâ€™t know how to track it


---

âœ… SOLUTION A (RECOMMENDED â€“ Clean & Correct)

âœ” Add a Primary Key (Best Practice)

Since your table tbl_category already has Id, use it.


---

1ï¸âƒ£ Update Category Model

namespace WebApplication1.Models
{
    public class Category
    {
        public int Id { get; set; }          // PRIMARY KEY
        public string CategoryName { get; set; }
    }
}


---

2ï¸âƒ£ Update Stored Procedure

ALTER PROCEDURE sp_Category_GetAll
AS
BEGIN
    SET NOCOUNT ON;

    SELECT Id, CategoryName
    FROM tbl_category
    ORDER BY CategoryName
END
GO


---

3ï¸âƒ£ Update View Dropdown (Use CategoryName as Value)

<select asp-for="Category">
    <option value="">-- Select Category --</option>
    @foreach (var item in categories)
    {
        <option value="@item.CategoryName">
            @item.CategoryName
        </option>
    }
</select>

âœ” EF Core is happy
âœ” Clean entity tracking
âœ” Reusable later for Category CRUD


---

âœ… SOLUTION B (QUICK FIX â€“ Keyless Entity)

Use this ONLY if you donâ€™t want CRUD on Category.


---

1ï¸âƒ£ Mark Entity as Keyless

ğŸ“ ApplicationDbContext.cs

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Category>().HasNoKey();
}


---

2ï¸âƒ£ Keep Model Simple

public class Category
{
    public string CategoryName { get; set; }
}


---

âš  Limitations of Keyless Entities

âŒ Cannot Insert / Update / Delete
âŒ Read-only
âŒ Not tracked


---

ğŸ† Which Should You Use?

Scenario	Recommendation

Real system	âœ… Solution A
Dropdown reference	âš  Solution B
Future CRUD	âœ… Solution A
Quick read-only	âš  Solution B


ğŸ‘‰ I strongly recommend Solution A
Youâ€™ll need it later anyway.


---

ğŸ”‘ Pro Tip (Important)

EF Core + Stored Procedures still require keys for mapping,
even if you never update the table.


---

ğŸš€ Next Step Options

I can help you:

âœ… Convert Category dropdown to ViewModel

âœ… Add Category CRUD

âœ… Add cascading dropdowns

âœ… Apply this fix to Meeting Locations / Departments


Just tell me what you want next ğŸ‘


**


InvalidOperationException: The entity type 'Category' requires a primary key to be defined. If you intended to use a keyless entity type, call 'HasNoKey' in 'OnModelCreating'. For more information on keyless entity types, see https://go.microsoft.com/fwlink/?linkid=2141943.

**

Youâ€™re getting that error because you have duplicate action methods with the same signature in the same controller.

This is a C# compile-time error, not an ASP.NET issue.


---

âŒ Whatâ€™s Wrong (Root Cause)

In your StudentsController, you defined these TWICE:

Duplicate methods

Create() GET

Create(Student student) POST

Edit(int id) GET

Edit(Student student) POST


C# does NOT allow two methods with:

Same method name

Same parameters

Same return type


Even if the code inside is different âŒ


---

âŒ Example of the Problem

You currently have both of these in the same controller:

// FIRST Create (GET)
public IActionResult Create()
{
    return View();
}

// SECOND Create (GET)
public async Task<IActionResult> Create()
{
    ViewBag.CategoryList = await _context.GetCategoriesAsync();
    return View();
}

â¡ï¸ Same name, same parameters â†’ compile error


---

âœ… Correct Approach

You should keep ONLY ONE version of each action, and merge the logic.

Below is the FIXED and CLEAN controller, with:

Category dropdown

Async

Stored procedures

No duplicate methods



---

âœ… FIXED StudentsController.cs (COPY THIS)

using Microsoft.AspNetCore.Mvc;
using WebApplication1.Data;
using WebApplication1.Models;

namespace WebApplication1.Controllers
{
    public class StudentsController : Controller
    {
        private readonly ApplicationDbContext _context;

        public StudentsController(ApplicationDbContext context)
        {
            _context = context;
        }

        // GET: Students
        public async Task<IActionResult> Index()
        {
            var students = await _context.GetStudentsAsync();
            return View(students);
        }

        // ================= CREATE =================

        // GET: Students/Create
        public async Task<IActionResult> Create()
        {
            ViewBag.CategoryList = await _context.GetCategoriesAsync();
            return View();
        }

        // POST: Students/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Student student)
        {
            if (!ModelState.IsValid)
            {
                ViewBag.CategoryList = await _context.GetCategoriesAsync();
                return View(student);
            }

            await _context.InsertStudentAsync(student);
            return RedirectToAction(nameof(Index));
        }

        // ================= EDIT =================

        // GET: Students/Edit/5
        public async Task<IActionResult> Edit(int id)
        {
            var student = (await _context.GetStudentsAsync())
                            .FirstOrDefault(x => x.Id == id);

            if (student == null)
                return NotFound();

            ViewBag.CategoryList = await _context.GetCategoriesAsync();
            return View(student);
        }

        // POST: Students/Edit
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(Student student)
        {
            if (!ModelState.IsValid)
            {
                ViewBag.CategoryList = await _context.GetCategoriesAsync();
                return View(student);
            }

            await _context.UpdateStudentAsync(student);
            return RedirectToAction(nameof(Index));
        }

        // ================= DELETE =================

        // GET: Students/Delete/5
        public async Task<IActionResult> Delete(int id)
        {
            var student = (await _context.GetStudentsAsync())
                            .FirstOrDefault(x => x.Id == id);

            if (student == null)
                return NotFound();

            return View(student);
        }

        // POST: Students/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            await _context.DeleteStudentAsync(id);
            return RedirectToAction(nameof(Index));
        }
    }
}


---

âœ… Why This Fix Works

âœ” Only one Create() GET
âœ” Only one Create(Student) POST
âœ” Only one Edit() GET
âœ” Only one Edit(Student) POST
âœ” Category dropdown loaded where needed
âœ” Async + Stored Procedure pattern preserved


---

ğŸ”‘ Important Rule to Remember

> One controller = one action name per parameter signature



If you need different behavior:

Use different method names

Or merge logic into one method (recommended)



---

ğŸš€ Recommended Next Improvements

If you want, I can help you:

âœ… Replace ViewBag with a ViewModel (best practice)

âœ… Add GetStudentById SP (avoid loading all students)

âœ… Add validation messages to dropdown

âœ… Apply this same fix to your Meeting Attendance project


Just tell me ğŸ‘


**

Please check code:

using Microsoft.AspNetCore.Mvc;
using System;
using WebApplication1.Data;
using WebApplication1.Models;

namespace WebApplication1.Controllers
{
    public class StudentsController : Controller
    {
        private readonly ApplicationDbContext _context;

        public StudentsController(ApplicationDbContext context)
        {
            _context = context;
        }

        // GET: Students
        public async Task<IActionResult> Index()
        {
            var students = await _context.GetStudentsAsync();
            return View(students);
        }

        // GET: Students/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Students/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Student student)
        {
            if (!ModelState.IsValid)
                return View(student);

            await _context.InsertStudentAsync(student);
            return RedirectToAction(nameof(Index));
        }

        // GET: Edit
        public async Task<IActionResult> Edit(int id)
        {
            var student = (await _context.GetStudentsAsync())
                            .FirstOrDefault(x => x.Id == id);

            if (student == null)
                return NotFound();

            return View(student);
        }

        // POST: Edit
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(Student student)
        {
            if (!ModelState.IsValid)
                return View(student);

            await _context.UpdateStudentAsync(student);
            return RedirectToAction(nameof(Index));
        }

        // GET: Delete(Confirm Page)
        public async Task<IActionResult> Delete(int id)
        {
            var student = (await _context.GetStudentsAsync())
                            .FirstOrDefault(x => x.Id == id);

            if (student == null)
                return NotFound();

            return View(student);
        }

        // POST: Delete

        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            await _context.DeleteStudentAsync(id);
            return RedirectToAction(nameof(Index));
        }




        // Create (GET)
        public async Task<IActionResult> Create()
        {
            ViewBag.CategoryList = await _context.GetCategoriesAsync();
            return View();
        }

        // Create (POST)

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Student student)
        {
            if (!ModelState.IsValid)
            {
                ViewBag.CategoryList = await _context.GetCategoriesAsync();
                return View(student);
            }

            await _context.InsertStudentAsync(student);
            return RedirectToAction(nameof(Index));
        }

        // Edit (GET)
        public async Task<IActionResult> Edit(int id)
        {
            var student = (await _context.GetStudentsAsync())
                            .FirstOrDefault(x => x.Id == id);

            if (student == null)
                return NotFound();

            ViewBag.CategoryList = await _context.GetCategoriesAsync();
            return View(student);
        }

        // Edit (POST)

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(Student student)
        {
            if (!ModelState.IsValid)
            {
                ViewBag.CategoryList = await _context.GetCategoriesAsync();
                return View(student);
            }

            await _context.UpdateStudentAsync(student);
            return RedirectToAction(nameof(Index));
        }


    }
}



Error:
1. Type 'StudentsController' already defines a member called 'Create' with the same parameter types
2. Type 'StudentsController' already defines a member called 'Edit' with the same parameter types


**


Below is a clean, async, production-style example to load Category as a dropdown from another table
tbl_category (CategoryName) using Stored Procedures + EF Core (.NET 8 MVC).

This pattern is exactly what youâ€™ll reuse for Locations, Roles, Departments, etc.


---

1ï¸âƒ£ Database â€“ Table (Reference)

tbl_category
------------
Id (INT, PK)
CategoryName (NVARCHAR(50))


---

2ï¸âƒ£ Stored Procedure â€“ Get Categories

CREATE PROCEDURE sp_Category_GetAll
AS
BEGIN
    SET NOCOUNT ON;

    SELECT CategoryName
    FROM tbl_category
    ORDER BY CategoryName
END
GO


---

3ï¸âƒ£ Model â€“ Category (View Model Friendly)

ğŸ“ Models â†’ Category.cs

namespace MvcEfCoreSample.Models
{
    public class Category
    {
        public string CategoryName { get; set; }
    }
}

> âœ” No ID needed if you only bind text
âœ” Simple and lightweight




---

4ï¸âƒ£ AppDbContext â€“ Async Category Loader

ğŸ“ Data â†’ AppDbContext.cs

Add:

public DbSet<Category> Categories { get; set; }

// Get categories for dropdown
public async Task<List<Category>> GetCategoriesAsync()
{
    return await Categories
        .FromSqlRaw("EXEC sp_Category_GetAll")
        .AsNoTracking()
        .ToListAsync();
}


---

5ï¸âƒ£ StudentsController â€“ Load Dropdown

ğŸ“ Controllers â†’ StudentsController.cs

ğŸ”¹ Create (GET)

public async Task<IActionResult> Create()
{
    ViewBag.CategoryList = await _context.GetCategoriesAsync();
    return View();
}


---

ğŸ”¹ Create (POST)

[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Create(Student student)
{
    if (!ModelState.IsValid)
    {
        ViewBag.CategoryList = await _context.GetCategoriesAsync();
        return View(student);
    }

    await _context.InsertStudentAsync(student);
    return RedirectToAction(nameof(Index));
}


---

ğŸ”¹ Edit (GET)

public async Task<IActionResult> Edit(int id)
{
    var student = (await _context.GetStudentsAsync())
                    .FirstOrDefault(x => x.Id == id);

    if (student == null)
        return NotFound();

    ViewBag.CategoryList = await _context.GetCategoriesAsync();
    return View(student);
}


---

ğŸ”¹ Edit (POST)

[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Edit(Student student)
{
    if (!ModelState.IsValid)
    {
        ViewBag.CategoryList = await _context.GetCategoriesAsync();
        return View(student);
    }

    await _context.UpdateStudentAsync(student);
    return RedirectToAction(nameof(Index));
}


---

6ï¸âƒ£ View â€“ Dropdown Category

ğŸ“ Views/Students/Create.cshtml

@model MvcEfCoreSample.Models.Student
@{
    var categories = ViewBag.CategoryList as List<MvcEfCoreSample.Models.Category>;
}

<div>
    <label>Category</label>
    <select asp-for="Category">
        <option value="">-- Select Category --</option>
        @foreach (var item in categories)
        {
            <option value="@item.CategoryName">
                @item.CategoryName
            </option>
        }
    </select>
</div>


---

ğŸ“ Views/Students/Edit.cshtml

@model MvcEfCoreSample.Models.Student
@{
    var categories = ViewBag.CategoryList as List<MvcEfCoreSample.Models.Category>;
}

<div>
    <label>Category</label>
    <select asp-for="Category">
        <option value="">-- Select Category --</option>
        @foreach (var item in categories)
        {
            <option value="@item.CategoryName"
                selected="@(item.CategoryName == Model.Category)">
                @item.CategoryName
            </option>
        }
    </select>
</div>


---

7ï¸âƒ£ Validation (Optional but Recommended)

ğŸ“ Models â†’ Student.cs

[Required(ErrorMessage = "Category is required")]
public string Category { get; set; }


---

8ï¸âƒ£ Best Practice Upgrade (Recommended)

Instead of ViewBag, use a ViewModel:

public class StudentViewModel
{
    public Student Student { get; set; }
    public List<Category> Categories { get; set; }
}

(Ask me if you want this refactor â€” itâ€™s cleaner.)


---

âœ… What You Have Now

âœ” Category dropdown from database
âœ” Stored procedure based
âœ” Async EF Core
âœ” Reusable pattern
âœ” Enterprise-ready


---

ğŸš€ Next Useful Enhancements

I can help you add:

âœ… â€œOthersâ€ option with textbox

âœ… Category CRUD page

âœ… Cascading dropdowns

âœ… Repository + Interface

âœ… Apply this to Meeting Location / Department


ğŸ‘‰ Just tell me what you want next ğŸ‘


**


Great question ğŸ‘
Letâ€™s add a new column Category to your project properly and cleanly, including:

âœ… Database
âœ… Stored Procedures
âœ… Model
âœ… DbContext
âœ… Controller
âœ… Views

This follows enterprise-safe steps so you wonâ€™t break existing data.


---

1ï¸âƒ£ Update Database (SQL Server)

ğŸ”¹ Add Column to Table

ALTER TABLE Students
ADD Category NVARCHAR(50) NULL;

> NULL is safe for existing records.




---

2ï¸âƒ£ Update Stored Procedures

âœ… Get All

ALTER PROCEDURE sp_Students_GetAll
AS
BEGIN
    SET NOCOUNT ON;

    SELECT Id, Name, Age, Category
    FROM Students
END
GO


---

âœ… Insert

ALTER PROCEDURE sp_Students_Insert
    @Name NVARCHAR(100),
    @Age INT,
    @Category NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    INSERT INTO Students (Name, Age, Category)
    VALUES (@Name, @Age, @Category)
END
GO


---

âœ… Update

ALTER PROCEDURE sp_Students_Update
    @Id INT,
    @Name NVARCHAR(100),
    @Age INT,
    @Category NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE Students
    SET Name = @Name,
        Age = @Age,
        Category = @Category
    WHERE Id = @Id
END
GO


---

âœ… Delete (No Change)

ALTER PROCEDURE sp_Students_Delete
    @Id INT
AS
BEGIN
    DELETE FROM Students
    WHERE Id = @Id
END
GO


---

3ï¸âƒ£ Update Model

ğŸ“ Models â†’ Student.cs

using System.ComponentModel.DataAnnotations;

namespace MvcEfCoreSample.Models
{
    public class Student
    {
        public int Id { get; set; }

        [Required]
        public string Name { get; set; }

        public int Age { get; set; }

        [Required]
        public string Category { get; set; }
    }
}


---

4ï¸âƒ£ Update AppDbContext (Async SP Calls)

ğŸ“ Data â†’ AppDbContext.cs

// INSERT
public async Task InsertStudentAsync(Student student)
{
    await Database.ExecuteSqlRawAsync(
        "EXEC sp_Students_Insert @Name, @Age, @Category",
        new SqlParameter("@Name", student.Name),
        new SqlParameter("@Age", student.Age),
        new SqlParameter("@Category", student.Category)
    );
}

// UPDATE
public async Task UpdateStudentAsync(Student student)
{
    await Database.ExecuteSqlRawAsync(
        "EXEC sp_Students_Update @Id, @Name, @Age, @Category",
        new SqlParameter("@Id", student.Id),
        new SqlParameter("@Name", student.Name),
        new SqlParameter("@Age", student.Age),
        new SqlParameter("@Category", student.Category)
    );
}

> âœ… GetStudentsAsync() already works as long as SP returns Category.




---

5ï¸âƒ£ Update Controller (No Logic Change)

Your controller already works â€” it automatically binds the new field.

âœ” No changes needed except views.


---

6ï¸âƒ£ Update Views

ğŸ“ Views/Students/Create.cshtml

<div>
    <label>Category</label>
    <input asp-for="Category" />
</div>


---

ğŸ“ Views/Students/Edit.cshtml

<div>
    <label>Category</label>
    <input asp-for="Category" />
</div>


---

ğŸ“ Views/Students/Index.cshtml

<th>Category</th>

<td>@item.Category</td>


---

ğŸ“ Views/Students/Delete.cshtml

<p>
    Category: <b>@Model.Category</b>
</p>


---

7ï¸âƒ£ Important Rules (VERY IMPORTANT)

âœ” Stored procedure column names must match model properties
âœ” SP parameter order must match your EXEC call
âœ” Use ALTER, not DROP & CREATE, for production


---

8ï¸âƒ£ What You Have Now âœ…

âœ” New column fully integrated
âœ” Async stored procedures
âœ” MVC binding works automatically
âœ” No EF migration needed (SP-based approach)


---

ğŸš€ Recommended Next Steps

Since youâ€™re building real systems, next I can help you with:

âœ… Dropdown Category (from database)

âœ… Validation (required / max length)

âœ… sp_Students_GetByCategory

âœ… Repository + Interface

âœ… Apply this same pattern to Meeting Attendance


ğŸ‘‰ Just tell me what you want next.



**

Great ğŸ‘
Letâ€™s extend your current setup and add ASYNC UPDATE & DELETE using Stored Procedures the proper, production-ready way.

Iâ€™ll give you:

1. SQL Stored Procedures


2. AppDbContext async methods


3. Controller async actions


4. Notes & best practices



All copy-paste ready.


---

1ï¸âƒ£ SQL Server â€“ Stored Procedures

âœ… UPDATE Student

CREATE PROCEDURE sp_Students_Update
    @Id INT,
    @Name NVARCHAR(100),
    @Age INT
AS
BEGIN
    UPDATE Students
    SET Name = @Name,
        Age = @Age
    WHERE Id = @Id
END
GO


---

âœ… DELETE Student

CREATE PROCEDURE sp_Students_Delete
    @Id INT
AS
BEGIN
    DELETE FROM Students
    WHERE Id = @Id
END
GO


---

2ï¸âƒ£ AppDbContext â€“ Async Methods

ğŸ“ Data â†’ AppDbContext.cs

Add these methods below your existing ones:

// UPDATE (Async)
public async Task UpdateStudentAsync(Student student)
{
    await Database.ExecuteSqlRawAsync(
        "EXEC sp_Students_Update @Id, @Name, @Age",
        new SqlParameter("@Id", student.Id),
        new SqlParameter("@Name", student.Name),
        new SqlParameter("@Age", student.Age)
    );
}

// DELETE (Async)
public async Task DeleteStudentAsync(int id)
{
    await Database.ExecuteSqlRawAsync(
        "EXEC sp_Students_Delete @Id",
        new SqlParameter("@Id", id)
    );
}

âœ” Uses parameterized queries
âœ” Safe from SQL injection
âœ” Async-ready


---

3ï¸âƒ£ StudentsController â€“ Async Actions

ğŸ“ Controllers â†’ StudentsController.cs

ğŸ”¹ GET: Edit

public async Task<IActionResult> Edit(int id)
{
    var student = (await _context.GetStudentsAsync())
                    .FirstOrDefault(x => x.Id == id);

    if (student == null)
        return NotFound();

    return View(student);
}


---

ğŸ”¹ POST: Edit

[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Edit(Student student)
{
    if (!ModelState.IsValid)
        return View(student);

    await _context.UpdateStudentAsync(student);
    return RedirectToAction(nameof(Index));
}


---

ğŸ”¹ GET: Delete (Confirm Page)

public async Task<IActionResult> Delete(int id)
{
    var student = (await _context.GetStudentsAsync())
                    .FirstOrDefault(x => x.Id == id);

    if (student == null)
        return NotFound();

    return View(student);
}


---

ğŸ”¹ POST: Delete

[HttpPost, ActionName("Delete")]
[ValidateAntiForgeryToken]
public async Task<IActionResult> DeleteConfirmed(int id)
{
    await _context.DeleteStudentAsync(id);
    return RedirectToAction(nameof(Index));
}


---

4ï¸âƒ£ Views Needed (Minimal)

ğŸ“ Views/Students/Edit.cshtml

@model MvcEfCoreSample.Models.Student

<h2>Edit Student</h2>

<form asp-action="Edit" method="post">
    <input type="hidden" asp-for="Id" />

    <div>
        <label>Name</label>
        <input asp-for="Name" />
    </div>

    <div>
        <label>Age</label>
        <input asp-for="Age" />
    </div>

    <button type="submit">Update</button>
</form>


---

ğŸ“ Views/Students/Delete.cshtml

@model MvcEfCoreSample.Models.Student

<h2>Delete Student</h2>

<p>Are you sure you want to delete <b>@Model.Name</b>?</p>

<form asp-action="Delete" method="post">
    <input type="hidden" asp-for="Id" />
    <button type="submit">Delete</button>
</form>


---

5ï¸âƒ£ Update Index.cshtml (Add Links)

<td>
    <a asp-action="Edit" asp-route-id="@item.Id">Edit</a> |
    <a asp-action="Delete" asp-route-id="@item.Id">Delete</a>
</td>


---

6ï¸âƒ£ What You Have Now âœ…

âœ” Full CRUD using Stored Procedures
âœ” Async / Await everywhere
âœ” Clean controller
âœ” Centralized database logic
âœ” Enterprise-ready structure


---

7ï¸âƒ£ Important Best Practices (Read This)

âœ” Use .AsNoTracking() for read SPs
âœ” Do NOT fetch all rows just to find one in large tables
âœ” For production, add:

SET NOCOUNT ON;

inside SPs


---

ğŸš€ Next Logical Upgrades (Highly Recommended)

I can now help you with:

âœ… sp_Students_GetById (avoid loading all records)

âœ… Repository + Interface (IStudentRepository)

âœ… Transaction handling

âœ… Output parameter (return inserted ID)

âœ… Convert this pattern to your Meeting Attendance system


ğŸ‘‰ Just tell me what you want next.


**


Perfect ğŸ‘ Letâ€™s convert everything to a proper async version using stored procedures + EF Core (.NET 8 MVC).

Below is the clean, recommended async pattern you can directly reuse in enterprise apps.


---

1ï¸âƒ£ Stored Procedures (Same as Before)

-- Get all students
CREATE PROCEDURE sp_Students_GetAll
AS
BEGIN
    SELECT Id, Name, Age
    FROM Students
END
GO

-- Insert student
CREATE PROCEDURE sp_Students_Insert
    @Name NVARCHAR(100),
    @Age INT
AS
BEGIN
    INSERT INTO Students (Name, Age)
    VALUES (@Name, @Age)
END
GO


---

2ï¸âƒ£ AppDbContext (ASYNC)

ğŸ“ Data â†’ AppDbContext.cs

using Microsoft.EntityFrameworkCore;
using Microsoft.Data.SqlClient;
using MvcEfCoreSample.Models;

namespace MvcEfCoreSample.Data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options)
            : base(options)
        {
        }

        public DbSet<Student> Students { get; set; }

        // GET ALL (Async)
        public async Task<List<Student>> GetStudentsAsync()
        {
            return await Students
                .FromSqlRaw("EXEC sp_Students_GetAll")
                .AsNoTracking()
                .ToListAsync();
        }

        // INSERT (Async)
        public async Task InsertStudentAsync(Student student)
        {
            await Database.ExecuteSqlRawAsync(
                "EXEC sp_Students_Insert @Name, @Age",
                new SqlParameter("@Name", student.Name),
                new SqlParameter("@Age", student.Age)
            );
        }
    }
}


---

3ï¸âƒ£ StudentsController (ASYNC)

ğŸ“ Controllers â†’ StudentsController.cs

using Microsoft.AspNetCore.Mvc;
using MvcEfCoreSample.Data;
using MvcEfCoreSample.Models;

namespace MvcEfCoreSample.Controllers
{
    public class StudentsController : Controller
    {
        private readonly AppDbContext _context;

        public StudentsController(AppDbContext context)
        {
            _context = context;
        }

        // GET: Students
        public async Task<IActionResult> Index()
        {
            var students = await _context.GetStudentsAsync();
            return View(students);
        }

        // GET: Students/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Students/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Student student)
        {
            if (!ModelState.IsValid)
                return View(student);

            await _context.InsertStudentAsync(student);
            return RedirectToAction(nameof(Index));
        }
    }
}


---

4ï¸âƒ£ Views (No Change)

Your Razor views remain exactly the same.
Async logic is controller + data layer only âœ”


---

5ï¸âƒ£ Why Async is the Best Practice

âœ” Non-blocking database calls
âœ” Better performance under load
âœ” Required for cloud & enterprise apps
âœ” Matches modern ASP.NET Core patterns


---

6ï¸âƒ£ Common Async Mistakes to Avoid âŒ

âŒ Mixing async with .Result or .Wait()
âŒ Forgetting await
âŒ Not returning Task<IActionResult>


---

7ï¸âƒ£ Recommended Next Step (Very Important)

For real systems, you should separate logic using:

Controllers
 â””â”€â”€ Interfaces
 â””â”€â”€ Repositories (DAL)
 â””â”€â”€ Stored Procedures

I can next help you with:

âœ… Async Update & Delete SP

âœ… Repository pattern (IStudentRepository)

âœ… Stored procedure with output parameter (return new ID)

âœ… Pagination + filtering

âœ… Transaction handling


ğŸ‘‰ Just tell me what you want next.


**

Sure ğŸ‘
Below is a simple and clean example of converting your StudentsController to use SQL Server stored procedures in ASP.NET Core MVC (.NET 8) with EF Core.

Iâ€™ll keep it copy-paste ready and aligned with how youâ€™ll later use stored procedures in your Meeting Attendance system.


---

1ï¸âƒ£ Create Stored Procedures in SQL Server

Run these in SQL Server Management Studio:

-- Get all students
CREATE PROCEDURE sp_Students_GetAll
AS
BEGIN
    SELECT Id, Name, Age
    FROM Students
END
GO

-- Insert student
CREATE PROCEDURE sp_Students_Insert
    @Name NVARCHAR(100),
    @Age INT
AS
BEGIN
    INSERT INTO Students (Name, Age)
    VALUES (@Name, @Age)
END
GO


---

2ï¸âƒ£ Update DbContext (IMPORTANT)

ğŸ“ Data â†’ AppDbContext.cs

Add this method (keep your DbSet):

using Microsoft.EntityFrameworkCore;
using MvcEfCoreSample.Models;

namespace MvcEfCoreSample.Data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options)
            : base(options)
        {
        }

        public DbSet<Student> Students { get; set; }

        // Stored Procedure: Get All Students
        public List<Student> GetStudents()
        {
            return Students
                .FromSqlRaw("EXEC sp_Students_GetAll")
                .AsNoTracking()
                .ToList();
        }

        // Stored Procedure: Insert Student
        public void InsertStudent(Student student)
        {
            Database.ExecuteSqlRaw(
                "EXEC sp_Students_Insert @Name, @Age",
                new SqlParameter("@Name", student.Name),
                new SqlParameter("@Age", student.Age)
            );
        }
    }
}

ğŸ‘‰ Donâ€™t forget to add:

using Microsoft.Data.SqlClient;


---

3ï¸âƒ£ Update StudentsController to Use Stored Procedures

ğŸ“ Controllers â†’ StudentsController.cs

using Microsoft.AspNetCore.Mvc;
using MvcEfCoreSample.Data;
using MvcEfCoreSample.Models;

namespace MvcEfCoreSample.Controllers
{
    public class StudentsController : Controller
    {
        private readonly AppDbContext _context;

        public StudentsController(AppDbContext context)
        {
            _context = context;
        }

        // GET: Students
        public IActionResult Index()
        {
            var students = _context.GetStudents(); // SP call
            return View(students);
        }

        // GET: Students/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Students/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult Create(Student student)
        {
            if (ModelState.IsValid)
            {
                _context.InsertStudent(student); // SP call
                return RedirectToAction(nameof(Index));
            }

            return View(student);
        }
    }
}


---

4ï¸âƒ£ Views (No Changes Needed)

Your existing views still work:

âœ” Index.cshtml
âœ” Create.cshtml

EF Core maps the stored procedure result directly to the Student model.


---

5ï¸âƒ£ Key Notes (Important for Real Projects)

âœ” Why this approach is good

Uses EF Core tracking + mapping

Safe from SQL injection

Easy to migrate to DAL / Repository pattern

Perfect for enterprise systems


âš  Common Rules

Column names returned by SP must match model properties

Stored procedures do not auto-track changes

Use .AsNoTracking() for read-only queries



---

6ï¸âƒ£ Optional: Async Version (Recommended)

If you want best practice:

public async Task<List<Student>> GetStudentsAsync()
{
    return await Students
        .FromSqlRaw("EXEC sp_Students_GetAll")
        .AsNoTracking()
        .ToListAsync();
}


---

ğŸš€ Next Enhancements (Tell me what you want)

I can help you add:

âœ… Update / Delete stored procedures

âœ… Repository + Interface (DAL pattern)

âœ… Output parameters (like auto-generated IDs)

âœ… Stored procedure with filtering

âœ… Bootstrap + validation

âœ… Authentication + role-based access


Just say â€œnext, add update & delete SPâ€ or â€œconvert to DALâ€ ğŸ‘


**

Below is a very simple, beginner-friendly tutorial to create an ASP.NET Core MVC (.NET 8.0) application using Entity Framework Core.
Iâ€™ll keep it step-by-step, minimal, and copy-paste ready ğŸ‘
(This is similar to what youâ€™ll use later for systems like your Meeting Attendance project.)


---

1ï¸âƒ£ Create the Project

Using Visual Studio

1. Open Visual Studio 2022


2. Create a new project


3. Choose ASP.NET Core Web App (Model-View-Controller)


4. Click Next


5. Set:

Project name: MvcEfCoreSample

Framework: .NET 8.0

Authentication: None



6. Click Create




---

2ï¸âƒ£ Install Required NuGet Packages

Open NuGet Package Manager and install:

Microsoft.EntityFrameworkCore.SqlServer
Microsoft.EntityFrameworkCore.Tools


---

3ï¸âƒ£ Create the Model (Entity)

ğŸ“ Models â†’ Student.cs

using System.ComponentModel.DataAnnotations;

namespace MvcEfCoreSample.Models
{
    public class Student
    {
        public int Id { get; set; }

        [Required]
        public string Name { get; set; }

        public int Age { get; set; }
    }
}


---

4ï¸âƒ£ Create the DbContext

ğŸ“ Data â†’ AppDbContext.cs

using Microsoft.EntityFrameworkCore;
using MvcEfCoreSample.Models;

namespace MvcEfCoreSample.Data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options)
            : base(options)
        {
        }

        public DbSet<Student> Students { get; set; }
    }
}


---

5ï¸âƒ£ Configure Database Connection

ğŸ“„ appsettings.json

{
  "ConnectionStrings": {
    "DefaultConnection": "Server=.;Database=MvcEfCoreDb;Trusted_Connection=True;TrustServerCertificate=True"
  }
}


---

6ï¸âƒ£ Register DbContext in Program.cs

ğŸ“„ Program.cs

using Microsoft.EntityFrameworkCore;
using MvcEfCoreSample.Data;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(
        builder.Configuration.GetConnectionString("DefaultConnection")
    ));

var app = builder.Build();

app.UseStaticFiles();
app.UseRouting();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();


---

7ï¸âƒ£ Create Controller

ğŸ“ Controllers â†’ StudentsController.cs

using Microsoft.AspNetCore.Mvc;
using MvcEfCoreSample.Data;
using MvcEfCoreSample.Models;

namespace MvcEfCoreSample.Controllers
{
    public class StudentsController : Controller
    {
        private readonly AppDbContext _context;

        public StudentsController(AppDbContext context)
        {
            _context = context;
        }

        // GET: Students
        public IActionResult Index()
        {
            var students = _context.Students.ToList();
            return View(students);
        }

        // GET: Students/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Students/Create
        [HttpPost]
        public IActionResult Create(Student student)
        {
            if (ModelState.IsValid)
            {
                _context.Students.Add(student);
                _context.SaveChanges();
                return RedirectToAction(nameof(Index));
            }
            return View(student);
        }
    }
}


---

8ï¸âƒ£ Create Views

ğŸ“ Views â†’ Students â†’ Index.cshtml

@model List<MvcEfCoreSample.Models.Student>

<h2>Student List</h2>

<a asp-action="Create">Add New</a>

<table border="1">
    <tr>
        <th>Name</th>
        <th>Age</th>
    </tr>

@foreach (var item in Model)
{
    <tr>
        <td>@item.Name</td>
        <td>@item.Age</td>
    </tr>
}
</table>


---

ğŸ“ Views â†’ Students â†’ Create.cshtml

@model MvcEfCoreSample.Models.Student

<h2>Add Student</h2>

<form asp-action="Create" method="post">
    <div>
        <label>Name</label>
        <input asp-for="Name" />
    </div>

    <div>
        <label>Age</label>
        <input asp-for="Age" />
    </div>

    <button type="submit">Save</button>
</form>


---

9ï¸âƒ£ Create Database (Migration)

Open Package Manager Console:

Add-Migration InitialCreate
Update-Database

âœ” This creates:

Database: MvcEfCoreDb

Table: Students



---

ğŸ”Ÿ Run the App

1. Run the project


2. Go to:



https://localhost:xxxx/Students

3. Add students â†’ data saved to SQL Server ğŸ‰




---

ğŸ§  What You Just Learned

âœ” MVC structure
âœ” EF Core DbContext
âœ” SQL Server connection
âœ” CRUD (Create + Read)
âœ” .NET 8 minimal hosting model


---

Next Steps (Recommended)

Since youâ€™re building real systems like Meeting Attendance & User Management, next we can add:

âœ… Edit / Delete

âœ… Bootstrap UI

âœ… Repository (DAL) pattern

âœ… Authentication (Login / Roles)

âœ… Stored Procedures with EF Core


ğŸ‘‰ Just tell me what you want to add next, and Iâ€™ll extend this tutorial step-by-step.
