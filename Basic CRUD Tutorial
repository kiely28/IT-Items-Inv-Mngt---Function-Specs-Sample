That error means:

EF Core refuses to compose LINQ on top of a stored procedure call, because stored procedures are non-composable SQL.
This happens when you do something like:

_context.Items
    .FromSqlInterpolated($"EXEC sp_GetItemById @Id={id}")
    .FirstOrDefaultAsync();   // ‚ùå causes composition

FirstOrDefaultAsync(), Where(), etc. = LINQ composition, so EF throws this exception.


---

‚úÖ THE FIX

You must call AsEnumerable() before doing any LINQ operation.

Replace this (WRONG):

var item = await _context.Items
    .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
    .AsNoTracking()
    .FirstOrDefaultAsync();

With this (CORRECT):

var item = _context.Items
    .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
    .AsNoTracking()
    .AsEnumerable()      // <--- IMPORTANT
    .FirstOrDefault();


---

‚úÖ UPDATED FIXED VERSION OF ALL SP CALLS

Get Item by ID (Details, Edit GET, Delete GET)

var item = _context.Items
    .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
    .AsNoTracking()
    .AsEnumerable()
    .FirstOrDefault();


---

Get All Items (Index)

This one is fine because no extra LINQ is applied:

var items = await _context.Items
    .FromSqlRaw("EXEC dbo.sp_GetAllItems")
    .AsNoTracking()
    .ToListAsync();


---

üõ† WHY THIS WORKS

FromSqlRaw / FromSqlInterpolated must be the final part of the SQL.

Calling First(), FirstOrDefault(), Where(), etc. modifies the SQL, so EF blocks it.

AsEnumerable() forces the SQL to execute first, then LINQ happens in-memory, which EF allows.



---

üöÄ DROP-IN PATCH FOR YOUR CONTROLLER

Apply this to all 3 methods:

Details(int id)

var item = _context.Items
    .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
    .AsNoTracking()
    .AsEnumerable()
    .FirstOrDefault();

if (item == null) return NotFound();

return View(item);

Edit(int id) GET

var item = _context.Items
    .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
    .AsNoTracking()
    .AsEnumerable()
    .FirstOrDefault();

if (item == null) return NotFound();

return View(item);

Delete(int id) GET

var item = _context.Items
    .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
    .AsNoTracking()
    .AsEnumerable()
    .FirstOrDefault();

if (item == null) return NotFound();

return View(item);


---

üéâ After applying these patches:

‚úî Details works
‚úî Edit (GET) works
‚úî Delete (GET) works
‚úî No more InvalidOperationException
‚úî No SQL composing over a stored procedure


---

Want me to regenerate the entire controller with all fixes applied?


**

Error when Saving, Click Details, Edit and Delete.

InvalidOperationException: 'FromSql' or 'SqlQuery' was called with non-composable SQL and with a query composing over it. Consider calling 'AsEnumerable' after the method to perform the composition on the client side.


**

Absolutely ‚Äî here is a complete, clean, ready-to-copy CRUD template using ASP.NET Core MVC 8 + EF Core 8 + Stored Procedures.
Everything is arranged in real project structure so you can paste it directly into your app.


---

‚úÖ FULL PROJECT TEMPLATE (COPIABLE FORMAT)

ASP.NET Core MVC 8 + EF Core 8 + SQL Stored Procedures


---

üìå 1. SQL Server ‚Äî Create Table + Stored Procedures

Copy & run in SSMS:

CREATE TABLE dbo.tbl_Items
(
    Id INT IDENTITY(1,1) PRIMARY KEY,
    Name NVARCHAR(200) NOT NULL,
    Description NVARCHAR(MAX) NULL,
    Quantity INT NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME()
);
GO

-- READ ALL
CREATE PROCEDURE dbo.sp_GetAllItems
AS
BEGIN
    SELECT Id, Name, Description, Quantity, CreatedAt
    FROM dbo.tbl_Items
    ORDER BY Id;
END
GO

-- READ BY ID
CREATE PROCEDURE dbo.sp_GetItemById
    @Id INT
AS
BEGIN
    SELECT Id, Name, Description, Quantity, CreatedAt
    FROM dbo.tbl_Items
    WHERE Id = @Id;
END
GO

-- INSERT
CREATE PROCEDURE dbo.sp_InsertItem
    @Name NVARCHAR(200),
    @Description NVARCHAR(MAX),
    @Quantity INT
AS
BEGIN
    INSERT INTO dbo.tbl_Items(Name, Description, Quantity)
    VALUES(@Name, @Description, @Quantity);

    SELECT SCOPE_IDENTITY() AS NewId;
END
GO

-- UPDATE
CREATE PROCEDURE dbo.sp_UpdateItem
    @Id INT,
    @Name NVARCHAR(200),
    @Description NVARCHAR(MAX),
    @Quantity INT
AS
BEGIN
    UPDATE dbo.tbl_Items
    SET Name = @Name,
        Description = @Description,
        Quantity = @Quantity
    WHERE Id = @Id;
END
GO

-- DELETE
CREATE PROCEDURE dbo.sp_DeleteItem
    @Id INT
AS
BEGIN
    DELETE FROM dbo.tbl_Items WHERE Id = @Id;
END
GO


---

üìå 2. appsettings.json (Connection String)

{
  "ConnectionStrings": {
    "DefaultConnection": "Server=YOUR_SERVER;Database=InventoryDB;Trusted_Connection=True;TrustServerCertificate=True;"
  },

  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },

  "AllowedHosts": "*"
}


---

üìå 3. Program.cs

using Microsoft.EntityFrameworkCore;
using InventoryApp.Data;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
}

app.UseStaticFiles();
app.UseRouting();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Items}/{action=Index}/{id?}");

app.Run();


---

üìå 4. Models/Item.cs

namespace InventoryApp.Models
{
    public class Item
    {
        public int Id { get; set; }
        public string Name { get; set; } = null!;
        public string? Description { get; set; }
        public int Quantity { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}


---

üìå 5. Data/ApplicationDbContext.cs

using Microsoft.EntityFrameworkCore;
using InventoryApp.Models;

namespace InventoryApp.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options) { }

        public DbSet<Item> Items { get; set; }
    }
}


---

üìå 6. Controllers/ItemsController.cs

üíØ Calls Stored Procedures only ‚Äî no EF Add/Update/Delete() used

using InventoryApp.Data;
using InventoryApp.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;

namespace InventoryApp.Controllers
{
    public class ItemsController : Controller
    {
        private readonly ApplicationDbContext _context;

        public ItemsController(ApplicationDbContext context)
        {
            _context = context;
        }

        // READ ALL
        public async Task<IActionResult> Index()
        {
            var items = await _context.Items
                .FromSqlRaw("EXEC dbo.sp_GetAllItems")
                .AsNoTracking()
                .ToListAsync();

            return View(items);
        }

        // READ BY ID
        public async Task<IActionResult> Details(int id)
        {
            var item = await _context.Items
                .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
                .AsNoTracking()
                .FirstOrDefaultAsync();

            if (item == null) return NotFound();

            return View(item);
        }

        // CREATE (GET)
        public IActionResult Create()
        {
            return View();
        }

        // CREATE (POST)
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Item item)
        {
            if (!ModelState.IsValid)
                return View(item);

            using var conn = _context.Database.GetDbConnection();
            await conn.OpenAsync();

            using var cmd = conn.CreateCommand();
            cmd.CommandText = "dbo.sp_InsertItem";
            cmd.CommandType = System.Data.CommandType.StoredProcedure;

            cmd.Parameters.Add(new SqlParameter("@Name", item.Name));
            cmd.Parameters.Add(new SqlParameter("@Description", (object?)item.Description ?? DBNull.Value));
            cmd.Parameters.Add(new SqlParameter("@Quantity", item.Quantity));

            using var reader = await cmd.ExecuteReaderAsync();
            int newId = 0;

            if (await reader.ReadAsync())
                newId = Convert.ToInt32(reader["NewId"]);

            return RedirectToAction(nameof(Details), new { id = newId });
        }

        // EDIT (GET)
        public async Task<IActionResult> Edit(int id)
        {
            var item = await _context.Items
                .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
                .AsNoTracking()
                .FirstOrDefaultAsync();

            if (item == null) return NotFound();

            return View(item);
        }

        // EDIT (POST)
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, Item item)
        {
            if (id != item.Id) return BadRequest();

            await _context.Database.ExecuteSqlInterpolatedAsync(
                $"EXEC dbo.sp_UpdateItem @Id = {item.Id}, @Name = {item.Name}, @Description = {item.Description}, @Quantity = {item.Quantity}");

            return RedirectToAction(nameof(Index));
        }

        // DELETE (GET)
        public async Task<IActionResult> Delete(int id)
        {
            var item = await _context.Items
                .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
                .AsNoTracking()
                .FirstOrDefaultAsync();

            if (item == null) return NotFound();

            return View(item);
        }

        // DELETE (POST)
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            await _context.Database.ExecuteSqlInterpolatedAsync(
                $"EXEC dbo.sp_DeleteItem @Id = {id}");

            return RedirectToAction(nameof(Index));
        }
    }
}


---

üìå 7. Views ‚Äî Fully Copiable CRUD Views

Create folder:
Views/Items/


---

‚úÖ Views/Items/Index.cshtml

@model IEnumerable<InventoryApp.Models.Item>

<h2>Items List</h2>

<p>
    <a class="btn btn-primary" href="/Items/Create">Create New</a>
</p>

<table class="table table-bordered">
    <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Quantity</th>
        <th>Created</th>
        <th></th>
    </tr>

@foreach (var item in Model)
{
    <tr>
        <td>@item.Name</td>
        <td>@item.Description</td>
        <td>@item.Quantity</td>
        <td>@item.CreatedAt</td>
        <td>
            <a href="/Items/Details/@item.Id">Details</a> |
            <a href="/Items/Edit/@item.Id">Edit</a> |
            <a href="/Items/Delete/@item.Id">Delete</a>
        </td>
    </tr>
}
</table>


---

‚úÖ Views/Items/Create.cshtml

@model InventoryApp.Models.Item

<h2>Create Item</h2>

<form method="post">
    <div class="form-group">
        <label>Name</label>
        <input class="form-control" name="Name" />
    </div>

    <div class="form-group">
        <label>Description</label>
        <textarea class="form-control" name="Description"></textarea>
    </div>

    <div class="form-group">
        <label>Quantity</label>
        <input class="form-control" name="Quantity" type="number" />
    </div>

    <button type="submit" class="btn btn-success">Save</button>
</form>


---

‚úÖ Views/Items/Edit.cshtml

@model InventoryApp.Models.Item

<h2>Edit Item</h2>

<form method="post">
    <input type="hidden" name="Id" value="@Model.Id" />

    <div class="form-group">
        <label>Name</label>
        <input class="form-control" name="Name" value="@Model.Name" />
    </div>

    <div class="form-group">
        <label>Description</label>
        <textarea class="form-control" name="Description">@Model.Description</textarea>
    </div>

    <div class="form-group">
        <label>Quantity</label>
        <input class="form-control" name="Quantity" type="number" value="@Model.Quantity" />
    </div>

    <button type="submit" class="btn btn-primary">Update</button>
</form>


---

‚úÖ Views/Items/Details.cshtml

@model InventoryApp.Models.Item

<h2>Item Details</h2>

<p><strong>Name:</strong> @Model.Name</p>
<p><strong>Description:</strong> @Model.Description</p>
<p><strong>Quantity:</strong> @Model.Quantity</p>
<p><strong>Created:</strong> @Model.CreatedAt</p>

<p>
    <a href="/Items/Edit/@Model.Id" class="btn btn-warning">Edit</a>
    <a href="/Items/Index" class="btn btn-secondary">Back</a>
</p>


---

‚úÖ Views/Items/Delete.cshtml

@model InventoryApp.Models.Item

<h2>Delete Item</h2>

<p>Are you sure you want to delete this item?</p>

<p><b>@Model.Name</b></p>

<form method="post">
    <button type="submit" class="btn btn-danger">Delete</button>
    <a href="/Items/Index" class="btn btn-secondary">Cancel</a>
</form>


---

üéâ DONE!

You now have:

‚úî Complete SQL
‚úî Complete Model
‚úî Complete DbContext
‚úî Complete Controller with Stored Procedures
‚úî Complete CRUD Razor Views
‚úî Fully working ASP.NET Core MVC 8 CRUD app


---

üìå Want me to zip all files into a single downloadable folder?

I can also generate:

‚úÖ Semantic UI + DataTables version
‚úÖ Bootstrap 5 styled UI
‚úÖ Version with Repository + Service layers
‚úÖ Version with Output Parameters instead of SELECT SCOPE_IDENTITY

Just tell me!


**

Nice ‚Äî I‚Äôll give you a compact, practical step-by-step tutorial to build a basic CRUD app using ASP.NET Core MVC 8 + EF Core 8 while using stored procedures in SQL Server for the database operations. I‚Äôll also call out an important limitation (EF Core ‚â† EF6) and show the recommended patterns to call stored procedures from EF Core. Wherever a web source strengthens a point I‚Äôll cite it.


---

TL;DR / Overview

1. Create SQL table tbl_Items and stored procedures (sp_GetAllItems, sp_GetItemById, sp_InsertItem, sp_UpdateItem, sp_DeleteItem).


2. Create ASP.NET Core MVC 8 project.


3. Add EF Core 8 and SQL Server packages.


4. Create Item model and ApplicationDbContext.


5. Use EF Core to call stored procedures: FromSqlRaw / FromSqlInterpolated for reads, and Database.ExecuteSqlRawAsync / ExecuteSqlInterpolatedAsync for CUD operations.


6. Build MVC controller + views that call those DbContext methods.



Important note: EF6 had built-in fluent mapping to map insert/update/delete directly to stored procedures. EF Core historically doesn‚Äôt provide the same automatic mapping for CUD via Fluent API ‚Äî instead you call stored procedures directly from code (or use ADO). I‚Äôll show the safe, modern approach. 


---

1) Create the SQL Server table + stored procedures

Example SQL (run in SSMS):

CREATE TABLE dbo.tbl_Items
(
    Id INT IDENTITY(1,1) PRIMARY KEY,
    Name NVARCHAR(200) NOT NULL,
    Description NVARCHAR(MAX) NULL,
    Quantity INT NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME()
);
GO

-- Read all
CREATE PROCEDURE dbo.sp_GetAllItems
AS
BEGIN
    SELECT Id, Name, Description, Quantity, CreatedAt
    FROM dbo.tbl_Items
    ORDER BY Id;
END
GO

-- Read by id
CREATE PROCEDURE dbo.sp_GetItemById
    @Id INT
AS
BEGIN
    SELECT Id, Name, Description, Quantity, CreatedAt
    FROM dbo.tbl_Items
    WHERE Id = @Id;
END
GO

-- Insert
CREATE PROCEDURE dbo.sp_InsertItem
    @Name NVARCHAR(200),
    @Description NVARCHAR(MAX),
    @Quantity INT
AS
BEGIN
    INSERT INTO dbo.tbl_Items(Name, Description, Quantity)
    VALUES(@Name, @Description, @Quantity);

    SELECT SCOPE_IDENTITY() AS NewId; -- return new id
END
GO

-- Update
CREATE PROCEDURE dbo.sp_UpdateItem
    @Id INT,
    @Name NVARCHAR(200),
    @Description NVARCHAR(MAX),
    @Quantity INT
AS
BEGIN
    UPDATE dbo.tbl_Items
    SET Name = @Name,
        Description = @Description,
        Quantity = @Quantity
    WHERE Id = @Id;
END
GO

-- Delete
CREATE PROCEDURE dbo.sp_DeleteItem
    @Id INT
AS
BEGIN
    DELETE FROM dbo.tbl_Items WHERE Id = @Id;
END
GO


---

2) Create the ASP.NET Core MVC 8 project & add packages

From command line (or use Visual Studio):

dotnet new mvc -n InventoryApp
cd InventoryApp

dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 8.*
dotnet add package Microsoft.EntityFrameworkCore.Tools --version 8.*

(You can scaffold controllers/views later ‚Äî I‚Äôll show manual controller code.)


---

3) Create the Item model

Models/Item.cs

public class Item
{
    public int Id { get; set; }
    public string Name { get; set; } = null!;
    public string? Description { get; set; }
    public int Quantity { get; set; }
    public DateTime CreatedAt { get; set; }
}


---

4) Setup ApplicationDbContext

Data/ApplicationDbContext.cs

using Microsoft.EntityFrameworkCore;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options) { }

    public DbSet<Item> Items { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // If you want to map a query type / keyless type for SP results, you can:
        // Example: modelBuilder.Entity<Item>().HasNoKey(); // but only for keyless query types
        // For normal entity with PK use the DbSet<Item> declared above.
        //
        // Note: EF Core doesn't allow fluent mapping of insert/update/delete to stored
        // procedures the same way EF6 did. So we'll call stored procedures explicitly.
        //
        // See EF Core docs: you can run SQL queries and map results through FromSqlRaw.
    }
}

Register it in Program.cs (or Startup.cs depending on project template):

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllersWithViews();

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();
// ... usual middleware + endpoints

Add connection string to appsettings.json.

Reference: EF Core docs on running SQL queries and mapping results. 


---

5) Call stored procedures from EF Core

Read (list and single)

Use FromSqlRaw or FromSqlInterpolated on a DbSet<T> to read results of a stored procedure:

// Get all items
var items = await _context.Items
    .FromSqlRaw("EXEC dbo.sp_GetAllItems")
    .AsNoTracking()
    .ToListAsync();

// Get single item by id
var id = 5;
var item = await _context.Items
    .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
    .AsNoTracking()
    .FirstOrDefaultAsync();

Notes

FromSqlRaw and FromSqlInterpolated require the returned columns to match the entity type (names / types). 


Insert / Update / Delete

Prefer: call Database.ExecuteSqlInterpolatedAsync (or ExecuteSqlRawAsync) to execute stored procs that don‚Äôt return full entity sets, or use FromSql for procs that return rows.

Insert example (returns new id):

// Insert and get new id
var name = "New item";
var description = "desc";
var qty = 10;

var result = await _context.Database
    .ExecuteSqlInterpolatedAsync($@"
        EXEC dbo.sp_InsertItem 
            @Name = {name}, 
            @Description = {description}, 
            @Quantity = {qty}");

If your stored proc returns a scalar (e.g. new id), EF Core ExecuteSql... does not return rows. In that case you can use ADO.NET via the DbConnection:

int newId;
using var conn = _context.Database.GetDbConnection();
await conn.OpenAsync();
using var cmd = conn.CreateCommand();
cmd.CommandText = "dbo.sp_InsertItem";
cmd.CommandType = System.Data.CommandType.StoredProcedure;

cmd.Parameters.Add(new SqlParameter("@Name", name));
cmd.Parameters.Add(new SqlParameter("@Description", (object?)description ?? DBNull.Value));
cmd.Parameters.Add(new SqlParameter("@Quantity", qty));

// If the proc SELECTs the new id, you can execute reader:
using var reader = await cmd.ExecuteReaderAsync();
await reader.ReadAsync();
newId = Convert.ToInt32(reader["NewId"]);

Update example:

await _context.Database.ExecuteSqlInterpolatedAsync(
    $"EXEC dbo.sp_UpdateItem @Id = {item.Id}, @Name = {item.Name}, @Description = {item.Description}, @Quantity = {item.Quantity}");

Delete example:

await _context.Database.ExecuteSqlInterpolatedAsync(
    $"EXEC dbo.sp_DeleteItem @Id = {id}");

References and deeper how-to for calling stored procs from EF Core. 


---

6) Example Controller (ItemsController)

Controllers/ItemsController.cs (minimal, async):

using Microsoft.AspNetCore.Mvc;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;

public class ItemsController : Controller
{
    private readonly ApplicationDbContext _context;
    public ItemsController(ApplicationDbContext context) => _context = context;

    // Index (list)
    public async Task<IActionResult> Index()
    {
        var items = await _context.Items
            .FromSqlRaw("EXEC dbo.sp_GetAllItems")
            .AsNoTracking()
            .ToListAsync();

        return View(items);
    }

    // Details
    public async Task<IActionResult> Details(int id)
    {
        var item = await _context.Items
            .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
            .AsNoTracking()
            .FirstOrDefaultAsync();

        if (item == null) return NotFound();
        return View(item);
    }

    // GET Create
    public IActionResult Create() => View();

    // POST Create
    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Create([Bind("Name,Description,Quantity")] Item item)
    {
        if (!ModelState.IsValid) return View(item);

        // Use ADO.NET approach if your proc returns new id; otherwise ExecuteSqlInterpolated
        using var conn = _context.Database.GetDbConnection();
        await conn.OpenAsync();
        using var cmd = conn.CreateCommand();
        cmd.CommandText = "dbo.sp_InsertItem";
        cmd.CommandType = System.Data.CommandType.StoredProcedure;
        cmd.Parameters.Add(new SqlParameter("@Name", item.Name));
        cmd.Parameters.Add(new SqlParameter("@Description", (object?)item.Description ?? DBNull.Value));
        cmd.Parameters.Add(new SqlParameter("@Quantity", item.Quantity));

        using var reader = await cmd.ExecuteReaderAsync();
        if (await reader.ReadAsync())
        {
            // optionally read returned NewId
            var newId = Convert.ToInt32(reader["NewId"]);
            // redirect to details
            return RedirectToAction(nameof(Details), new { id = newId });
        }

        return RedirectToAction(nameof(Index));
    }

    // GET Edit
    public async Task<IActionResult> Edit(int id)
    {
        var item = await _context.Items
            .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
            .AsNoTracking()
            .FirstOrDefaultAsync();

        if (item == null) return NotFound();
        return View(item);
    }

    // POST Edit
    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Edit(int id, [Bind("Id,Name,Description,Quantity")] Item item)
    {
        if (id != item.Id) return BadRequest();
        if (!ModelState.IsValid) return View(item);

        await _context.Database.ExecuteSqlInterpolatedAsync(
            $"EXEC dbo.sp_UpdateItem @Id = {item.Id}, @Name = {item.Name}, @Description = {item.Description}, @Quantity = {item.Quantity}");

        return RedirectToAction(nameof(Index));
    }

    // GET Delete
    public async Task<IActionResult> Delete(int id)
    {
        var item = await _context.Items
            .FromSqlInterpolated($"EXEC dbo.sp_GetItemById @Id = {id}")
            .AsNoTracking()
            .FirstOrDefaultAsync();

        if (item == null) return NotFound();
        return View(item);
    }

    // POST DeleteConfirmed
    [HttpPost, ActionName("Delete")]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> DeleteConfirmed(int id)
    {
        await _context.Database.ExecuteSqlInterpolatedAsync($"EXEC dbo.sp_DeleteItem @Id = {id}");
        return RedirectToAction(nameof(Index));
    }
}


---

7) Views

Use normal Razor views created by scaffolding or hand-write minimal forms. The controller above expects typical Index, Details, Create, Edit, Delete views. You can scaffold them in Visual Studio using the ItemsController and Item model as usual, then replace EF usage with your stored-proc calls if scaffold used direct DbContext operations.

For a starter, you can scaffold CRUD views and then adapt the controller to call SPs instead of direct _context.Add/SaveChanges.

Microsoft's official CRUD tutorial for MVC + EF Core is a good companion when building views. 


---

8) Where EF Core differs from EF6 (why we call procs explicitly)

EF6 allowed mapping CUD operations to stored procedures with the Fluent API (code-first). EF Core does not provide the same automatic, built-in Fluent mapping for CUD in the same way. The practical effect: in EF Core you generally call stored procs explicitly (via FromSql* or Database.ExecuteSql* / raw ADO) when you want to use them. 



---

9) Tips, common pitfalls, and best practices

Parameter safety: use FromSqlInterpolated or add SqlParameter objects to avoid SQL injection.

Mapping columns: columns returned by the stored proc must match the entity property names and types or use a keyless type. 

Transactions: If you need transactions spanning stored-proc calls, use _context.Database.BeginTransactionAsync() and commit/rollback.

Performance: Stored procedures can help for complex logic, but modern EF Core LINQ often produces efficient SQL ‚Äî measure before rewriting everything to SPs.

Logging: enable EF logging to inspect generated SQL or SP calls.

Testing: write integration tests hitting a test DB to ensure SPs and EF calls work together.



---

10) Quick links / references

EF Core: SQL queries (FromSqlRaw, etc.) ‚Äî Microsoft docs. 

ASP.NET Core MVC + EF Core CRUD tutorial ‚Äî Microsoft docs. 

EF Core "what's new" / EF8 reference. 

Discussion / issue about mapping CUD to stored procedures in EF Core (historical background). 

StackOverflow & practical Q&A on calling stored procedures with EF Core. 



---

Wrap-up

If you want, I can:

Generate complete Razor views for Index/Create/Edit/Details/Delete that match the sample controller above.

Create a full sample repo (all files) you can clone and run locally.

Show the ADO.NET version for insert that reads output parameters or returns the new id.


Which of those would you like me to produce next? (I can create the views or the full repository right here.)
